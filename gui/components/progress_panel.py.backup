# -*- coding: utf-8 -*-
"""
Progress panel component for EH Downloader
"""

import tkinter as tk
from tkinter import ttk
from datetime import datetime
import threading
import time
import os
from typing import Dict, Any, Optional
from config.settings import *
from config.constants import *

class EHDownloaderProgressPanel:
    def __init__(self, parent):
        self.parent = parent
        
        # ⭐Phase1: ProgressTrackerのオブザーバー登録⭐
        self._setup_progress_tracker_observer()
        
        # ⭐追加: StateManagerのオブザーバー登録（プログレスバー更新用）⭐
        self._setup_state_manager_observer()
        
        # タイマー関連
        self.elapsed_time_timer_id = None
        self.total_elapsed_seconds = 0
        self.last_elapsed_update_time = None  # ⭐追加: 経過時間更新用のタイムスタンプ⭐
        
        # 別ウィンドウ関連
        self.separate_window = None
        self.separate_window_progress_bars = []
        # 状態管理はStateManager経由（self.is_running、self.paused、self.url_status、self.progress_barsは削除）
        
        # プログレスバー関連
        self.progress_update_lock = threading.Lock()
        self.progress_visible = False
        self.progress_container = None
        self.current_gallery_title = ""
        self.main_v_pane = None  # create_log_panelで設定される
        
        # メインウィンドウプログレスバー関連の初期化
        self.current_progress_frame = None
        self.current_progress_bar = None
        self.current_progress_title = None
        self.current_progress_status = None
        
        # 状態管理はStateManager経由（self.url_status、self.progress_barsは削除）
        self.current_download_start_time = None
        
        # オートスクロール機能
        self.auto_scroll_enabled = False
        
        # パフォーマンス最適化用
        self.last_status_update_time = {}
        self.status_update_interval = 1.0  # 1秒間隔で更新制限
        
        # ⭐最適化: 最新のアクティブなプログレスバーのインデックスを保持⭐
        self.latest_active_index = -1  # 最新のアクティブなプログレスバーのインデックス
        
        # ⭐修正: 初期化時にプログレスバー表示制限を適用⭐
        self.parent.root.after(100, self._check_progress_retention_limit)
    
    # ⭐リファクタリング: プログレスバーGUI統合メソッド⭐
    def _ensure_progress_bar_gui(self, url_index: int, progress_info: Dict = None, is_main_window: bool = False) -> Optional[Dict[str, Any]]:
        """
        プログレスバーのGUI要素を確保（生成または更新）
        
        ⭐根本修正: メインウィンドウの場合、常にStateManagerから最新情報を取得⭐
        
        Args:
            url_index: URL番号
            progress_info: プログレスバー情報（Noneの場合はStateManagerから取得）
            is_main_window: True=メインウィンドウ, False=ダウンロードマネージャー
        
        Returns:
            GUI要素辞書 {'frame', 'bar', 'status', 'title', 'open_folder_btn'}
        """
        try:
            self.log(f"[DEBUG] _ensure_progress_bar_gui開始: url_index={url_index}, is_main_window={is_main_window}, progress_info={'あり' if progress_info else 'なし'}", "debug")
            
            # ⭐修正: progress_infoがNoneの場合のみStateManagerから取得（二重取得を防ぐ）⭐
            if progress_info is None:
                self.log(f"[DEBUG] progress_info is None: StateManagerから取得開始", "debug")
                if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                    fresh_info = self.parent.downloader_core.state_manager.get_progress_bar(url_index)
                    if fresh_info:
                        progress_info = fresh_info
                        self.log(f"[DEBUG] StateManagerから情報取得成功: title='{progress_info.get('title', '')[:20]}', keys={list(progress_info.keys())}", "debug")
                    else:
                        # フォールバック: 空の情報を作成
                        progress_info = {
                            'title': '準備中...',
                            'current': 0,
                            'total': 1,
                            'status': '待機中',
                            'url': '',
                            'start_time': None
                        }
                        self.log(f"[DEBUG] フォールバック情報を使用", "debug")
            else:
                self.log(f"[DEBUG] progress_infoあり: title='{progress_info.get('title', '')[:20]}', status='{progress_info.get('status', '')[:20]}', current={progress_info.get('current')}/{progress_info.get('total')}", "debug")
            
            if is_main_window:
                # ⭐修正: latest_active_indexを更新⭐
                if url_index is not None and url_index >= 0:
                    self.latest_active_index = url_index
                
                # メインウィンドウ用
                if not self.current_progress_frame or not self.current_progress_frame.winfo_exists():
                    # 生成
                    self.log(f"[DEBUG] メインウィンドウ: プログレスバー生成", "debug")
                    return self._create_main_window_progress_gui(progress_info, url_index)
                else:
                    # 更新
                    self.log(f"[DEBUG] メインウィンドウ: プログレスバー更新", "debug")
                    widgets = {
                        'frame': self.current_progress_frame,
                        'bar': self.current_progress_bar,
                        'status': self.current_progress_status,
                        'title': self.current_progress_title
                    }
                    self._update_progress_gui_widgets(widgets, progress_info)
                    self.log(f"[DEBUG] メインウィンドウ: 更新完了", "debug")
                    return widgets
            else:
                # ダウンロードマネージャー用
                existing = self._find_separate_window_progress_by_url_index(url_index)
                if existing:
                    # 更新
                    self._update_progress_gui_widgets(existing, progress_info)
                    return existing
                else:
                    # 生成
                    return self._create_separate_window_progress_gui(progress_info, url_index)
        except Exception as e:
            self.log(f"[ERROR] _ensure_progress_bar_gui: {e}", "error")
            import traceback
            traceback.print_exc()
            return None
    
    def _create_main_window_progress_gui(self, progress_info: Dict, url_index: int) -> Dict[str, Any]:
        """メインウィンドウのプログレスバーGUIを生成（初回のみ呼ばれる想定）"""
        try:
            # ⭐修正: 既存フレーム破棄は行わない（_ensure_progress_bar_guiで制御）⭐
            # プログレスバーコンテナが存在しない場合は作成
            if not self.progress_container or not self.progress_container.winfo_exists():
                self.progress_container = ttk.Frame(self.main_v_pane)
                if self.main_v_pane and self.progress_container not in self.main_v_pane.panes():
                    self.main_v_pane.add(self.progress_container, height=150, before=self.parent.bottom_pane)
            
            # 共通メソッドでGUI要素を生成
            widgets = self._create_progress_bar_widgets(
                self.progress_container,
                progress_info,
                url_index=url_index,
                show_number=False,
                is_main_window=True
            )
            
            if widgets:
                self.current_progress_frame = widgets['frame']
                self.current_progress_bar = widgets['bar']
                self.current_progress_status = widgets['status']
                self.current_progress_title = widgets['title']
                self.open_folder_btn = widgets['open_folder_btn']
                return widgets
            else:
                self.log("[ERROR] _create_main_window_progress_gui: widgets is None", "error")
                return None
                
        except Exception as e:
            self.log(f"[ERROR] _create_main_window_progress_gui: {e}", "error")
            import traceback
            traceback.print_exc()
            return None
    
    def _create_separate_window_progress_gui(self, progress_info: Dict, url_index: int) -> Dict[str, Any]:
        """ダウンロードマネージャーのプログレスバーGUIを生成"""
        try:
            if not self.separate_window or not self.separate_window.winfo_exists():
                return None
            
            # スクロール可能なフレーム内に配置
            scroll_frame = None
            for child in self.separate_window.winfo_children():
                if isinstance(child, ttk.Frame):
                    for grandchild in child.winfo_children():
                        if isinstance(grandchild, tk.Canvas):
                            scroll_frame = grandchild.nametowidget(grandchild.winfo_children()[0])
                            break
                    if scroll_frame:
                        break
            
            if not scroll_frame:
                self.log("[ERROR] _create_separate_window_progress_gui: scroll_frame not found", "error")
                return None
            
            # 共通メソッドでGUI要素を生成
            widgets = self._create_progress_bar_widgets(
                scroll_frame,
                progress_info,
                url_index=url_index,
                show_number=True,
                is_main_window=False
            )
            
            if widgets:
                # ダウンロードマネージャーのリストに追加
                widgets['url_index'] = url_index
                self.separate_window_progress_bars.append(widgets)
                return widgets
            else:
                self.log("[ERROR] _create_separate_window_progress_gui: widgets is None", "error")
                return None
                
        except Exception as e:
            self.log(f"[ERROR] _create_separate_window_progress_gui: {e}", "error")
            import traceback
            traceback.print_exc()
            return None
    
    def _find_separate_window_progress_by_url_index(self, url_index: int) -> Optional[Dict[str, Any]]:
        """ダウンロードマネージャーから指定url_indexのプログレスバーを検索"""
        try:
            for progress in self.separate_window_progress_bars:
                if progress.get('url_index') == url_index:
                    return progress
            return None
        except Exception as e:
            self.log(f"[ERROR] _find_separate_window_progress_by_url_index: {e}", "error")
            return None
    
    def _update_progress_gui_widgets(self, widgets: Dict[str, Any], progress_info: Dict):
        """
        プログレスバーGUI要素を更新（メインウィンドウ/ダウンロードマネージャー共通）
        
        ユーザー指摘の解決: タイトルが正しく設定されるように修正
        """
        try:
            self.log(f"[DEBUG] _update_progress_gui_widgets開始: widgets_keys={list(widgets.keys())}, progress_title='{progress_info.get('title', '')[:20]}'", "debug")
            
            # タイトル更新
            title_widget = widgets.get('title')
            if title_widget and hasattr(title_widget, 'config'):
                self.log(f"[DEBUG] タイトル更新開始", "debug")
                title = progress_info.get('title', '準備中...')
                # ⭐修正: Tkウィジェット名が表示されないように、文字列のみを設定⭐
                if isinstance(title, str):
                    title_widget.config(text=title)
                    self.log(f"[DEBUG] タイトル更新完了: '{title[:30]}'", "debug")
                elif hasattr(title, 'cget'):
                    # Tkウィジェットの場合はエラー
                    title_widget.config(text="[エラー: タイトルがウィジェットです]")
                    self.log(f"[ERROR] タイトルがウィジェットです", "error")
            
            # プログレスバー更新
            bar_widget = widgets.get('bar')
            if bar_widget and hasattr(bar_widget, '__setitem__'):
                self.log(f"[DEBUG] プログレスバー更新開始", "debug")
                current = progress_info.get('current', 0)
                total = progress_info.get('total', 1)
                progress_value = (current / total) * 100 if total > 0 else 0
                progress_value = max(0, min(100, progress_value))
                bar_widget['value'] = progress_value
                self.log(f"[DEBUG] プログレスバー更新完了: {current}/{total} ({progress_value:.1f}%)", "debug")
            
            # ステータス更新
            status_widget = widgets.get('status')
            if status_widget and hasattr(status_widget, 'config'):
                self.log(f"[DEBUG] ステータス更新開始", "debug")
                status_text = self._build_status_text(progress_info)
                status_widget.config(text=status_text)
                self.log(f"[DEBUG] ステータス更新完了: '{status_text[:30]}'", "debug")
            
            self.log(f"[DEBUG] _update_progress_gui_widgets完了", "debug")
                
        except Exception as e:
            self.log(f"[ERROR] _update_progress_gui_widgets: {e}", "error")
            import traceback
            traceback.print_exc()
    
    def _build_status_text(self, progress_info: Dict) -> str:
        """
        ステータステキストを構築（統一フォーマット）
        
        ユーザー指摘の解決: 「ダウンロード中」→「状態:ダウンロード中」に統一
        """
        try:
            # ⭐防御的コーディング: Noneチェックとデフォルト値を追加⭐
            current = progress_info.get('current') if progress_info.get('current') is not None else 0
            total = progress_info.get('total') if progress_info.get('total') is not None else 0
            status = progress_info.get('status') if progress_info.get('status') is not None else '待機中'
            
            # 型チェック
            if not isinstance(current, (int, float)):
                current = 0
            if not isinstance(total, (int, float)):
                total = 0
            if not isinstance(status, str):
                status = '待機中'
            
            parts = []
            
            # ⭐追加: 中断状態を視覚的に表示⭐
            if '一時停止' in status or 'paused' in status.lower() or '中断' in status:
                parts.append("⏸")
            
            # ページ数
            if total > 0:
                parts.append(f"ページ {int(current)}/{int(total)}")
            
            # 経過時間と残り時間
            elapsed_time = progress_info.get('elapsed_time')
            estimated_remaining = progress_info.get('estimated_remaining')
            
            # Noneチェックと型チェック
            if elapsed_time is not None and isinstance(elapsed_time, (int, float)) and elapsed_time > 0:
                elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                parts.append(f"経過: {elapsed_str}")
                
                if estimated_remaining is not None and isinstance(estimated_remaining, (int, float)) and estimated_remaining > 0:
                    remaining_str = f"{int(estimated_remaining//60):02d}:{int(estimated_remaining%60):02d}"
                    parts.append(f"残り: {remaining_str}")
            
            # ダウンロード範囲
            download_range_info = progress_info.get('download_range_info')
            if download_range_info and isinstance(download_range_info, dict) and download_range_info.get('enabled'):
                range_start = download_range_info.get('start', 0)
                range_end = download_range_info.get('end')
                if range_end is not None:
                    parts.append(f"ダウンロード範囲: {range_start}～{range_end}")
                else:
                    parts.append(f"ダウンロード範囲: {range_start}～∞")
            
            # 状態（常に「状態:」プレフィックスを追加）
            if "状態:" not in status:
                parts.append(f"状態: {status}")
            else:
                parts.append(status)
            
            return " | ".join(parts) if parts else "状態: 待機中"
            
        except Exception as e:
            self.log(f"[ERROR] _build_status_text: {e}", "error")
            import traceback
            self.log(f"[ERROR] _build_status_text詳細: {traceback.format_exc()}", "error")
            return "状態: エラー"
        
    def _get_progress_bars(self):
        """StateManagerから全てのプログレスバーを取得（ヘルパーメソッド）
        
        Returns:
            Dict[int, Dict]: url_index -> progress_bar辞書のマッピング（後方互換性のため辞書形式）
        """
        if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
            try:
                # get_all_progress_bars()はProgressBarオブジェクトを返す
                progress_bars = self.parent.downloader_core.state_manager.get_all_progress_bars()
                # ProgressBarオブジェクトを辞書に変換（GUI用）
                result = {}
                for idx, pb in progress_bars.items():
                    try:
                        if hasattr(pb, 'to_dict'):
                            # ProgressBarオブジェクトの場合
                            result[idx] = pb.to_dict()
                        elif isinstance(pb, dict):
                            # 既に辞書の場合（後方互換性）
                            result[idx] = pb
                        else:
                            # その他の場合はスキップ
                            self.log(f"[WARNING] Unknown progress_bar type at index {idx}: {type(pb)}", "warning")
                            continue
                    except Exception as e:
                        self.log(f"[ERROR] Failed to convert progress_bar at index {idx}: {e}", "error")
                        continue
                return result
            except Exception as e:
                self.log(f"[ERROR] Failed to get progress bars: {e}", "error")
                return {}
        return {}
    
    def _get_progress_bar(self, url_index):
        """StateManagerから指定されたurl_indexのプログレスバーを取得（ヘルパーメソッド）
        
        Returns:
            Dict or None: progress_bar辞書（後方互換性のため辞書形式）
        """
        if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
            # get_progress_bar()は既に辞書を返す（後方互換性API）
            return self.parent.downloader_core.state_manager.get_progress_bar(url_index)
        return None
    
    def _create_progress_bar_widgets(self, parent_frame, progress_info, url_index=None, show_number=False, is_main_window=False):
        """
        プログレスバーGUI要素を生成（メインウィンドウ/ダウンロードマネージャー共通）
        
        Args:
            parent_frame: 親フレーム
            progress_info: プログレス情報辞書（to_dict()で変換済み）
            url_index: URLインデックス（オプション）
            show_number: 連番表示フラグ（ダウンロードマネージャー用）
            is_main_window: メインウィンドウ用フラグ
        
        Returns:
            dict: 生成されたGUI要素の辞書
        """
        try:
            # progress_infoが辞書であることを確認
            if not isinstance(progress_info, dict):
                self.log(f"[ERROR] progress_infoが辞書ではありません: {type(progress_info)}", "error")
                return None
            
            # ⭐修正: ProgressBar.to_dict()が平坦な構造を返すため、'state'キーは不要⭐
            # タイトル取得
            title = progress_info.get('title', '')
            
            # タイトルが空の場合、parentから取得を試みる
            if not title or title == "準備中...":
                if hasattr(self.parent, 'current_gallery_title') and self.parent.current_gallery_title:
                    title = self.parent.current_gallery_title
                elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'current_gallery_title'):
                    title = self.parent.downloader_core.current_gallery_title
            
            # それでもタイトルが空の場合、フォルダ名を使用
            if not title or title == "準備中...":
                url = progress_info.get('url', '')
                if url:
                    if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'managed_folders'):
                        normalized_url = self.parent.normalize_url(url) if hasattr(self.parent, 'normalize_url') else url
                        if normalized_url in self.parent.downloader_core.managed_folders:
                            save_folder = self.parent.downloader_core.managed_folders[normalized_url]
                            if save_folder:
                                folder_name = os.path.basename(save_folder)
                                if folder_name:
                                    title = folder_name
            
            # それでもタイトルが空の場合は「準備中...」をデフォルト表示
            if not title:
                title = "準備中..."
            
            # 保存フォルダの情報を取得
            url = progress_info.get('url', '')
            save_folder = ""
            if url:
                if hasattr(self.parent, 'normalize_url'):
                    normalized_url = self.parent.normalize_url(url)
                elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'normalize_url'):
                    normalized_url = self.parent.downloader_core.normalize_url(url)
                else:
                    normalized_url = url
                
                if normalized_url and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'managed_folders') and normalized_url in self.parent.downloader_core.managed_folders:
                    save_folder = self.parent.downloader_core.managed_folders[normalized_url] or ''
            
            # プログレスバーフレーム作成
            if show_number and url_index is not None:
                frame_text = f"ダウンロード進捗 ({url_index + 1})"
            else:
                frame_text = "現在のダウンロード進捗"
            
            progress_frame = ttk.LabelFrame(parent_frame, text=frame_text)
            if is_main_window:
                progress_frame.pack(fill="both", expand=True, padx=5, pady=5)
            else:
                progress_frame.pack(fill="x", expand=True, padx=5, pady=2)
            
            # ヘッダーフレーム
            header_frame = ttk.Frame(progress_frame)
            header_frame.pack(fill="x", padx=5, pady=2)
            
            # 保存フォルダを開くボタン
            if is_main_window:
                open_folder_btn = ttk.Button(header_frame, text="📁", 
                                            command=self._open_current_folder, width=3)
            else:
                open_folder_btn = ttk.Button(header_frame, text="📁", width=3, state="disabled")
                # フォルダボタンのcommand設定
                def get_folder_from_managed_folders(progress_info):
                    """progress_infoのURLを使ってmanaged_foldersからフォルダを取得して開く"""
                    url = progress_info.get('url', '')
                    if url:
                        if hasattr(self.parent, 'normalize_url'):
                            normalized_url = self.parent.normalize_url(url)
                        elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'normalize_url'):
                            normalized_url = self.parent.downloader_core.normalize_url(url)
                        else:
                            normalized_url = url
                        
                        if normalized_url and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'managed_folders') and normalized_url in self.parent.downloader_core.managed_folders:
                            folder = self.parent.downloader_core.managed_folders[normalized_url]
                            if folder and os.path.exists(folder):
                                self._open_specific_folder(folder)
                            else:
                                self.log("フォルダが見つかりません", "error")
                        else:
                            self.log("フォルダ情報が見つかりません", "error")
                    else:
                        self.log("URL情報が見つかりません", "error")
                
                # ⭐修正: フォルダが存在する場合、またはmanaged_foldersにURLがある場合はボタンを有効化⭐
                should_enable_button = False
                if save_folder and os.path.exists(save_folder):
                    should_enable_button = True
                else:
                    # managed_foldersから確認
                    progress_url = progress_info.get('url', '')
                    if progress_url:
                        if hasattr(self.parent, 'normalize_url'):
                            normalized_url = self.parent.normalize_url(progress_url)
                        elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'normalize_url'):
                            normalized_url = self.parent.downloader_core.normalize_url(progress_url)
                        else:
                            normalized_url = progress_url
                        
                        if normalized_url and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'managed_folders'):
                            if normalized_url in self.parent.downloader_core.managed_folders:
                                folder = self.parent.downloader_core.managed_folders[normalized_url]
                                if folder and os.path.exists(folder):
                                    should_enable_button = True
                
                if should_enable_button:
                    open_folder_btn.config(state="normal", command=lambda pi=progress_info: get_folder_from_managed_folders(pi))
                    # ToolTipを追加
                    from gui.components.options_panel import ToolTip
                    ToolTip(open_folder_btn, "保存フォルダを開く")
                else:
                    # ToolTipを追加（無効状態でも）
                    from gui.components.options_panel import ToolTip
                    ToolTip(open_folder_btn, "保存フォルダ（準備中）")
            
            open_folder_btn.pack(side="right", anchor="e", padx=(5, 0))
            
            # タイトル表示（ハイパーリンク化）
            # ⭐修正: タイトルを直接設定（Tkウィジェット名の表示を防止）⭐
            title_label = tk.Label(header_frame, text=title, 
                                 fg="black", cursor="hand2" if title and title != "準備中..." else "arrow", 
                                 font=("Arial", 9))
            title_label.pack(side="left", anchor="w", padx=(0, 10))
            
            # URLリンク設定
            # ⭐修正: progress_infoから確実にURLを取得⭐
            fixed_url = progress_info.get('url', url) if progress_info.get('url') else url
            # ⭐修正: titleを使用（title_display_textは削除済み）⭐
            if fixed_url and title and title != "準備中...":
                def create_open_url_handler(gallery_url):
                    def open_url_handler(event):
                        try:
                            # ⭐修正: 正しいURLを使用してギャラリーを開く⭐
                            self._open_gallery_url(gallery_url)
                        except Exception as e:
                            self.log(f"URL開封エラー: {e}", "error")
                    return open_url_handler
                
                open_url_handler = create_open_url_handler(fixed_url)
                title_label.bind("<Button-1>", open_url_handler)
                if show_number:
                    title_label.bind("<Enter>", lambda e: title_label.config(fg="blue"))
                else:
                    title_label.bind("<Enter>", lambda e: title_label.config(fg="gray"))
                title_label.bind("<Leave>", lambda e: title_label.config(fg="black"))
            
            # ステータス表示
            initial_status = progress_info.get('status', '')
            # 進捗情報を取得
            current = progress_info.get('current', 0)
            total = progress_info.get('total', 0)
            
            # 状態が空または「状態: 待機中」の場合、またはページ数情報が含まれていない場合は、URLから状態を取得
            if not initial_status or initial_status == "状態: 待機中" or (current > 0 and total > 0 and "ページ" not in initial_status):
                progress_url = progress_info.get('url', '')
                if progress_url:
                    download_status = self._get_download_status(progress_url)
                    # ⭐修正: 既に「状態:」が含まれている場合は追加しない⭐
                    if "状態:" in initial_status:
                        # 既存の状態を保持しつつ、ページ数情報のみ追加
                        if current > 0 and total > 0 and "ページ" not in initial_status:
                            initial_status = f"ページ {current}/{total} | {initial_status}"
                    else:
                        # 進捗情報を取得
                        if current > 0 and total > 0:
                            initial_status = f"ページ {current}/{total} | 状態: {download_status}"
                        else:
                            initial_status = f"状態: {download_status}"
                else:
                    if "状態:" not in initial_status:
                        initial_status = "状態: 待機中"
            
            # ページ数情報が含まれていない場合、既存のcurrent/totalから補完
            if current > 0 and total > 0 and "ページ" not in initial_status:
                if initial_status:
                    initial_status = f"ページ {current}/{total} | {initial_status}"
                else:
                    initial_status = f"ページ {current}/{total} | 状態: 待機中"
            
            # ⭐追加: ダウンロード範囲情報を追加⭐
            progress_url = progress_info.get('url', '')
            if progress_url:
                # ⭐修正: progress_infoからdownload_range_infoを取得（優先）⭐
                download_range_info = progress_info.get('download_range_info')
                if download_range_info and download_range_info.get('enabled'):
                    # ⭐修正: download_range_infoから直接テキストを生成（最新の値を確実に使用）⭐
                    range_start = download_range_info.get('start', 0)
                    range_end = download_range_info.get('end')
                    if range_end is not None:
                        download_range_text = f"ダウンロード範囲: {range_start}～{range_end}"
                    else:
                        download_range_text = f"ダウンロード範囲: {range_start}～∞"
                else:
                    # ⭐修正: download_range_infoがない場合のみ、_get_download_range_textを使用（フォールバック）⭐
                    download_range_text = self._get_download_range_text(progress_url)
                
                if download_range_text:
                    if initial_status:
                        initial_status = f"{initial_status} | {download_range_text}"
                    else:
                        initial_status = download_range_text

            
            # ステータスラベル
            if not initial_status:
                initial_status = "待機中" if is_main_window else "状態: 待機中"
            
            status_label = ttk.Label(progress_frame, text=initial_status)
            status_label.pack(anchor="w", padx=5, pady=2)
            
            # プログレスバー
            progress_bar = ttk.Progressbar(progress_frame, mode='determinate', maximum=100)
            current = progress_info.get('current', 0)
            total = progress_info.get('total', 0)
            if total > 0:
                progress_value = (current / total) * 100
                progress_value = max(0, min(100, progress_value))
            else:
                progress_value = 0
            progress_bar['value'] = progress_value
            progress_bar.pack(fill="x", expand=True, padx=5, pady=(2, 5))
            
            return {
                'frame': progress_frame,
                'bar': progress_bar,
                'status': status_label,
                'title': title_label,
                'open_folder_btn': open_folder_btn,
                'url': url,
                'url_index': url_index,
                'save_folder': save_folder
            }
        except Exception as e:
            self.log(f"プログレスバーウィジェット作成エラー: {e}", "error")
            import traceback
            self.log(f"詳細: {traceback.format_exc()}", "error")
            return None
    
    def _setup_state_listeners(self):
        """StateManagerの状態変更リスナーを設定（Observer パターン）"""
        try:
            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                state_manager = self.parent.downloader_core.state_manager
                # プログレスバー更新イベントをリッスン
                state_manager.add_state_listener('progress_bar_update', self._on_progress_bar_updated)
                state_manager.add_state_listener('progress_bar_created', self._on_progress_bar_created)  # ⭐修正: progress_bar → progress_bar_created⭐
                # タイマー管理イベントをリッスン
                state_manager.add_state_listener('elapsed_time_start', self._on_elapsed_time_start)
                state_manager.add_state_listener('elapsed_time_reset', self._on_elapsed_time_reset)
                # ⭐追加: URL状態変更をリッスン（背景色更新の自動化）⭐
                state_manager.add_state_listener('url_status', self._on_url_status_changed)
        except Exception as e:
            self.log(f"状態リスナー設定エラー: {e}", "error")
    
    def _on_url_status_changed(self, url_status_dict: Dict[str, str], old_value: Any = None):
        """URL状態変更時のコールバック（背景色更新の自動化）"""
        try:
            # メインスレッドでGUI更新
            def update_gui():
                try:
                    for url, status in url_status_dict.items():
                        # URL背景色を自動更新
                        # ⭐修正: progress_panelにはupdate_url_backgroundがないため、url_panelのみ更新⭐
                        # URLパネルに通知
                        if hasattr(self.parent, 'url_panel') and hasattr(self.parent.url_panel, 'update_url_background'):
                            self.parent.url_panel.update_url_background(url)
                    
                    # ⭐追加: URL進捗を更新⭐
                    if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                        state_manager = self.parent.downloader_core.state_manager
                        completed_count = state_manager.get_completed_url_count()
                        # ⭐修正: get_total_url_countが存在しない場合は、_total_url_countから直接取得⭐
                        if hasattr(state_manager, '_state_lock') and hasattr(state_manager, '_total_url_count'):
                            with state_manager._state_lock:
                                total_count = getattr(state_manager, '_total_url_count', 0)
                        else:
                            total_count = 0
                        if total_count > 0:
                            self.update_url_progress(completed_count, total_count)
                except Exception as e:
                    self.log(f"URL状態変更イベントハンドラエラー: {e}", "error")
            
            if hasattr(self.parent, 'root'):
                self.parent.root.after(0, update_gui)
        except Exception as e:
            self.log(f"URL状態変更イベントハンドラエラー: {e}", "error")
    
    def _on_progress_bar_updated(self, data: Dict[str, Any], old_value: Any = None):
        """プログレスバー更新イベントハンドラ（非同期GUI更新）"""
        try:
            url_index = data.get('url_index')
            if url_index is None:
                return
            
            # ⭐非同期GUI更新: メインスレッドで実行⭐
            # ⭐修正: ダウンロードマネージャーとメインウィンドウのプログレスバーを排他表示・排他更新にする⭐
            def update_gui():
                try:
                    # StateManagerから最新のプログレスバー情報を取得
                    if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                        progress_info = self.parent.downloader_core.state_manager.get_progress_bar(url_index)
                        if progress_info:
                            # ⭐修正: ダウンロードマネージャーとメインウィンドウの両方を更新（ダウンロードマネージャーが開いている場合は両方、閉じている場合はメインウィンドウのみ）⭐
                            if self.separate_window and self.separate_window.winfo_exists():
                                # ダウンロードマネージャーが開いている場合は両方を更新
                                self._update_separate_window_progress_bar(url_index, progress_info)
                                # メインウィンドウも更新（最新の状態を反映）
                                self._update_main_window_progress_bar(url_index, progress_info)
                            else:
                                # ダウンロードマネージャーが閉じている場合はメインウィンドウのみ更新
                                self._update_main_window_progress_bar(url_index, progress_info)
                except Exception as e:
                    self.log(f"プログレスバー更新エラー: {e}", "error")
            
            # メインスレッドで実行
            if hasattr(self.parent, 'root'):
                self.parent.root.after(0, update_gui)
        except Exception as e:
            self.log(f"プログレスバー更新イベントハンドラエラー: {e}", "error")
    
    def _on_progress_bar_created(self, data: Dict[str, Any], old_value: Any = None):
        """プログレスバー作成イベントハンドラ（非同期GUI更新）"""
        try:
            url_index = data.get('url_index')
            if url_index is None:
                return
            
            # ⭐修正: メインウィンドウとダウンロードマネージャーの両方でプログレスバーを更新⭐
            # ⭐非同期GUI更新: メインスレッドで実行⭐
            def update_gui():
                try:
                    # StateManagerから最新のプログレスバー情報を取得
                    if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                        progress_info = self.parent.downloader_core.state_manager.get_progress_bar(url_index)
                        if progress_info:
                            # ⭐修正: ダウンロードマネージャーが開いている場合は両方を更新⭐
                            if self.separate_window and self.separate_window.winfo_exists():
                                # ダウンロードマネージャーにプログレスバーを追加（重複チェックあり）
                                self._add_progress_bar_to_separate_window(url_index, progress_info)
                            # ⭐修正: メインウィンドウのプログレスバーも更新（ダウンロード範囲を表示するため）⭐
                            self._update_main_window_progress_bar(url_index, progress_info)
                except Exception as e:
                    self.log(f"プログレスバー作成エラー: {e}", "error")
                    import traceback
                    self.log(f"詳細: {traceback.format_exc()}", "error")
            
            # メインスレッドで実行
            if hasattr(self.parent, 'root'):
                self.parent.root.after(0, update_gui)
        except Exception as e:
            self.log(f"プログレスバー作成イベントハンドラエラー: {e}", "error")
            import traceback
            self.log(f"詳細: {traceback.format_exc()}", "error")
    
    def _on_elapsed_time_start(self, data: Any = None):
        """経過時間タイマー開始イベントハンドラ"""
        try:
            if data is not None:
                # dataがfloatの場合は直接使用、辞書の場合は'start_time'キーから取得
                if isinstance(data, (int, float)):
                    start_time = float(data)
                elif isinstance(data, dict):
                    start_time = data.get('start_time')
                else:
                    start_time = None
                
                if start_time:
                    self._start_elapsed_time_timer_internal(start_time)
        except Exception as e:
            self.log(f"経過時間タイマー開始エラー: {e}", "error")
    
    def _on_elapsed_time_reset(self, data: Dict[str, Any] = None):
        """経過時間タイマーリセットイベントハンドラ"""
        try:
            self._stop_elapsed_time_timer()
            self.total_elapsed_seconds = 0
            if hasattr(self, 'last_elapsed_update_time'):
                self.last_elapsed_update_time = None
        except Exception as e:
            self.log(f"経過時間タイマーリセットエラー: {e}", "error")
    
    def _update_progress_bar_widgets(self, widgets: Dict[str, Any], progress_info: Dict[str, Any], is_main_window: bool = False):
        """
        プログレスバーウィジェットを更新（メインウィンドウ/ダウンロードマネージャー共通）
        
        Args:
            widgets: 更新するGUI要素の辞書 {'bar', 'status', 'title'}
            progress_info: プログレス情報辞書
            is_main_window: メインウィンドウ用フラグ
        """
        try:
            # ⭐修正: ProgressBar.to_dict()の平坦な構造に対応⭐
            current = progress_info.get('current', 0)
            total = progress_info.get('total', 0)
            title = progress_info.get('title', '準備中...')
            status = progress_info.get('status', '')
            
            # プログレスバーを更新
            if widgets.get('bar'):
                try:
                    if total > 0:
                        progress_value = (current / total) * 100
                        progress_value = max(0, min(100, progress_value))
                        widgets['bar']['value'] = progress_value
                    else:
                        widgets['bar']['value'] = 0
                except (tk.TclError, AttributeError):
                    pass
            
            # タイトルを更新
            if widgets.get('title'):
                try:
                    if title and title != "準備中...":
                        widgets['title'].config(text=title)
                except (tk.TclError, AttributeError):
                    pass
            
            # ステータスを更新
            if widgets.get('status'):
                try:
                    # ステータステキストを構築
                    status_text = status if status else ''
                    
                    # ステータスが空または不完全な場合は、詳細情報を構築
                    if not status_text or (status_text and 'ページ' not in status_text and total > 0):
                        # ダウンロード状態を確認
                        progress_url = progress_info.get('url', '')
                        download_status = self._get_download_status(progress_url) if progress_url else "待機中"
                        
                        # ⭐修正: 経過時間計算（完了時も保持、保存された経過時間を優先）⭐
                        # 既存のプログレスバーに保存されている経過時間を使用（完了時も保持）
                        saved_elapsed_time = progress_info.get('elapsed_time', 0)
                        elapsed_time = 0
                        current_time = time.time()
                        
                        if saved_elapsed_time > 0:
                            # 保存された経過時間を使用（完了時も保持）
                            elapsed_time = saved_elapsed_time
                        else:
                            # 保存された経過時間がない場合のみ計算
                            start_time = progress_info.get('start_time')
                            if start_time:
                                elapsed_time = current_time - start_time
                                # StateManagerから中断時間を取得して除外
                                if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                                    state_manager = self.parent.downloader_core.state_manager
                                    total_paused_time = state_manager.get_total_paused_time()
                                    elapsed_time -= total_paused_time
                                    # 現在中断中の場合、中断開始からの時間も除外
                                    paused_start = state_manager.get_elapsed_time_paused_start()
                                    if paused_start and state_manager.is_paused():
                                        elapsed_time -= (current_time - paused_start)
                                # 計算した経過時間を保存（次回使用するため）
                                progress_info['elapsed_time'] = elapsed_time
                            elif getattr(self, 'current_download_start_time', None):
                                elapsed_time = current_time - self.current_download_start_time
                                # StateManagerから中断時間を取得して除外
                                if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                                    state_manager = self.parent.downloader_core.state_manager
                                    total_paused_time = state_manager.get_total_paused_time()
                                    elapsed_time -= total_paused_time
                                    # 現在中断中の場合、中断開始からの時間も除外
                                    paused_start = state_manager.get_elapsed_time_paused_start()
                                    if paused_start and state_manager.is_paused():
                                        elapsed_time -= (current_time - paused_start)
                                # 計算した経過時間を保存（次回使用するため）
                                progress_info['elapsed_time'] = elapsed_time
                        
                        # 進捗情報を生成
                        is_completed = (current >= total and total > 0)
                        parts = []
                        
                        # ⭐修正: elapsed_time > 0 の条件を削除（0秒でも表示）⭐
                        if current > 0 and total > 0:
                            # elapsed_timeが0の場合も経過時間を表示（00:00）
                            estimated_total_time = elapsed_time * (total / current) if elapsed_time > 0 and current > 0 else 0
                            remaining_time = max(0, estimated_total_time - elapsed_time)
                            elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                            remaining_str = f"{int(remaining_time//60):02d}:{int(remaining_time%60):02d}"
                            
                            if is_completed:
                                parts.append(f"ページ {current}/{total} | 経過: {elapsed_str}")
                            else:
                                parts.append(f"ページ {current}/{total} | 経過: {elapsed_str} | 残り: {remaining_str}")
                        elif total > 0:
                            parts.append(f"ページ {current}/{total}")
                        
                        # ⭐修正: download_range_infoを優先的に使用（古い設定値を参照しない）⭐
                        download_range_info = progress_info.get('download_range_info')
                        if download_range_info and download_range_info.get('enabled'):
                            # download_range_infoから直接テキストを生成（最新の値を確実に使用）
                            range_start = download_range_info.get('start', 0)
                            range_end = download_range_info.get('end')
                            if range_end is not None:
                                download_range_text = f"ダウンロード範囲: {range_start}～{range_end}"
                            else:
                                download_range_text = f"ダウンロード範囲: {range_start}～∞"
                            if download_range_text:
                                parts.append(download_range_text)
                        elif progress_url:
                            # ⭐修正: download_range_infoがない場合のみ、_get_download_range_textを使用（フォールバック）⭐
                            download_range_text = self._get_download_range_text(progress_url)
                            if download_range_text:
                                parts.append(download_range_text)
                        
                        # 状態情報を追加（既存のstatusに「状態:」が含まれていない場合のみ追加）
                        existing_status_has_state = any("状態:" in part for part in parts)
                        if not existing_status_has_state:
                            if is_completed:
                                parts.append("状態: 完了")
                            elif current == 0 and total == 0:
                                parts.append("状態: 待機中")
                            elif download_status == "中断":
                                parts.append("状態: 中断")
                            elif download_status == "エラー":
                                parts.append("状態: エラー")
                            elif current < total:
                                parts.append("状態: ダウンロード中")  # ⭐修正: 全てのケースで「状態:」を追加⭐
                            else:
                                parts.append(f"状態: {download_status}")  # ⭐修正: その他のケースも統一⭐
                        
                        status_text = " | ".join(parts) if parts else "状態: 待機中"
                    # statusにページ情報が含まれていない場合のみ追加
                    elif 'ページ' not in status_text and total > 0:
                        status_text = f"ページ {current}/{total} | {status_text}"
                    
                    widgets['status'].config(text=status_text)
                except (tk.TclError, AttributeError):
                    pass
        except Exception as e:
            self.log(f"プログレスバーウィジェット更新エラー: {e}", "error")
    
    def _update_main_window_progress_bar(self, url_index: int, progress_info: Dict[str, Any]):
        """メインウィンドウのプログレスバーを更新（リアルタイム更新対応、一元化版）"""
        try:
            # ⭐修正: StateManagerから最新のプログレスバー情報を取得（常に最新の状態を反映）⭐
            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                latest_progress_info = self.parent.downloader_core.state_manager.get_progress_bar(url_index)
                if latest_progress_info:
                    progress_info = latest_progress_info
            
            # ⭐修正: 常に最新のアクティブなプログレスバーを表示（url_indexが大きいものを優先）⭐
            if url_index >= 0:
                # 既存のlatest_active_indexより新しいURLの場合は更新
                if self.latest_active_index < 0 or url_index >= self.latest_active_index:
                    self.latest_active_index = url_index
                # 最新のアクティブなプログレスバーのみ表示
                if url_index == self.latest_active_index:
                    # ⭐一元化: 共通メソッドを使用してプログレスバーを更新⭐
                    widgets = {
                        'bar': self.current_progress_bar if hasattr(self, 'current_progress_bar') else None,
                        'status': self.current_progress_status if hasattr(self, 'current_progress_status') else None,
                        'title': self.current_progress_title if hasattr(self, 'current_progress_title') else None
                    }
                    self._update_progress_bar_widgets(widgets, progress_info, is_main_window=True)
                    
                    # ⭐追加: 1秒後に再度更新（経過時間をリアルタイムに更新）⭐
                    if hasattr(self.parent, 'root'):
                        # 既存の更新タイマーをキャンセル
                        if hasattr(self, '_main_progress_update_timer'):
                            try:
                                self.parent.root.after_cancel(self._main_progress_update_timer)
                            except:
                                pass
                        
                        # 新しいタイマーを設定（ダウンロード中のみ）
                        status = progress_info.get('status', '')
                        if 'ダウンロード中' in status or 'DL中' in status or status == 'ダウンロード中':
                            self._main_progress_update_timer = self.parent.root.after(
                                1000, 
                                lambda: self._update_main_window_progress_bar(url_index, progress_info)
                            )
            else:
                # 最新のプログレスバーでない場合は、_show_latest_progress_in_main_window()を呼び出して最新を表示
                self._show_latest_progress_in_main_window()
        except Exception as e:
            self.log(f"メインウィンドウプログレスバー更新エラー: {e}", "error")
    
    def _update_separate_window_progress_bar(self, url_index: int, progress_info: Dict[str, Any]):
        """ダウンロードマネージャーのプログレスバーを更新"""
        try:
            if not self.separate_window or not self.separate_window.winfo_exists():
                return
            
            # ⭐修正: StateManagerから最新のプログレスバー情報を取得（常に最新の状態を反映）⭐
            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                latest_progress_info = self.parent.downloader_core.state_manager.get_progress_bar(url_index)
                if latest_progress_info:
                    progress_info = latest_progress_info
            
            # ⭐修正: 既存のプログレスバーを検索（url_indexで確認）⭐
            existing_progress = None
            for sep_progress in self.separate_window_progress_bars:
                sep_url_index = sep_progress.get('url_index')
                if sep_url_index is not None and sep_url_index == url_index:
                    existing_progress = sep_progress
                    break
            
            if existing_progress:
                # 既存のプログレスバーを更新
                self._update_existing_separate_window_progress_bar(url_index, progress_info, existing_progress)
            else:
                # 新しいプログレスバーを追加（重複チェックは_add_progress_bar_to_separate_window内で行う）
                self._add_progress_bar_to_separate_window(url_index, progress_info)
        except Exception as e:
            self.log(f"ダウンロードマネージャープログレスバー更新エラー: {e}", "error")
            import traceback
            self.log(f"詳細: {traceback.format_exc()}", "error")
    
    def _add_progress_bar_to_separate_window(self, url_index: int, progress_info: Dict[str, Any]):
        """ダウンロードマネージャーにプログレスバーを追加"""
        try:
            if not self.separate_window or not self.separate_window.winfo_exists():
                return
            
            # ⭐修正: 既に存在するかチェック（url_indexで確認、重複防止）⭐
            for sep_progress in self.separate_window_progress_bars:
                sep_url_index = sep_progress.get('url_index')
                if sep_url_index is not None and sep_url_index == url_index:
                    # 既に存在する場合は更新のみ（重複作成を防ぐ）
                    self.log(f"[DEBUG] プログレスバー既存（更新のみ）: url_index={url_index}", "debug")
                    self._update_existing_separate_window_progress_bar(url_index, progress_info, sep_progress)
                    return
            
            # プログレスバーを作成
            self.log(f"[DEBUG] プログレスバー新規作成: url_index={url_index}, 現在数={len(self.separate_window_progress_bars)}", "debug")
            self._create_progress_bar_in_separate_window_from_info(progress_info, url_index)
        except Exception as e:
            self.log(f"ダウンロードマネージャープログレスバー追加エラー: {e}", "error")
            import traceback
            self.log(f"詳細: {traceback.format_exc()}", "error")
    
    def _update_existing_separate_window_progress_bar(self, url_index: int, progress_info: Dict[str, Any], existing_progress: Dict[str, Any]):
        """既存のダウンロードマネージャーのプログレスバーを更新（一元化版）"""
        try:
            # ⭐一元化: 共通メソッドを使用してプログレスバーを更新⭐
            widgets = {
                'bar': existing_progress.get('bar'),
                'status': existing_progress.get('status'),
                'title': existing_progress.get('title')
            }
            self._update_progress_bar_widgets(widgets, progress_info, is_main_window=False)
        except Exception as e:
            self.log(f"既存プログレスバー更新エラー: {e}", "error")
        
    def create_log_panel(self, parent_pane):
        """ログパネルを作成"""
        # ⭐修正: parent_paneはbottom_paneなので、親のmain_v_paneを取得⭐
        self.bottom_pane = parent_pane  # bottom_paneを保持
        # main_v_paneは親ウィンドウから取得（bottom_paneの親）
        if hasattr(self.parent, 'main_v_pane'):
            self.main_v_pane = self.parent.main_v_pane
        else:
            # フォールバック: parent_paneの親を取得
            self.main_v_pane = parent_pane.master if hasattr(parent_pane, 'master') else parent_pane
        log_frame = ttk.LabelFrame(parent_pane, text="ログ")
        parent_pane.add(log_frame)
        log_frame.grid_rowconfigure(0, weight=1)
        log_frame.grid_columnconfigure(0, weight=1)

        self.log_text = tk.Text(log_frame, wrap="word", height=6, state='disabled', bg='white')
        self.log_text.grid(row=0, column=0, sticky="nsew")

        # ドラッグ&ドロップ機能
        try:
            import tkinterdnd2
            if hasattr(tkinterdnd2, 'DND_FILES') and hasattr(self.log_text, 'drop_target_register'):
                self.log_text.drop_target_register(tkinterdnd2.DND_FILES, tkinterdnd2.DND_TEXT)
                self.log_text.dnd_bind('<<Drop>>', self.parent._handle_drop)
        except Exception as e:
            print(f"Log area DnD initialization failed: {e}")

        log_scrollbar_y = ttk.Scrollbar(log_frame, orient="vertical", command=self.log_text.yview)
        log_scrollbar_y.grid(row=0, column=1, sticky="ns")
        self.log_text.config(yscrollcommand=log_scrollbar_y.set)
        
        log_scrollbar_x = ttk.Scrollbar(log_frame, orient="horizontal", command=self.log_text.xview)
        log_scrollbar_x.grid(row=1, column=0, sticky="ew")
        self.log_text.config(xscrollcommand=log_scrollbar_x.set)

        # ログエリア下部の進捗・時間表示
        status_frame = ttk.Frame(log_frame)
        status_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=5, pady=2)
        status_frame.grid_columnconfigure(1, weight=1)
        
        # 左側：URL進捗表示
        self.url_progress_label = ttk.Label(status_frame, text="URL進捗: 0/0 (0%)")
        self.url_progress_label.grid(row=0, column=0, sticky="w")
        
        # 右側：経過時間表示
        self.elapsed_time_label = ttk.Label(status_frame, text="経過時間: 00:00:00")
        self.elapsed_time_label.grid(row=0, column=2, sticky="e")
        
    def update_url_progress(self, completed, total):
        """URL進捗を更新"""
        if hasattr(self, 'url_progress_label'):
            # ⭐修正: totalが0の場合はStateManagerから取得⭐
            if total == 0 and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                state_manager = self.parent.downloader_core.state_manager
                if hasattr(state_manager, '_state_lock') and hasattr(state_manager, '_total_url_count'):
                    with state_manager._state_lock:
                        total = getattr(state_manager, '_total_url_count', 0)
            percentage = int((completed / total * 100)) if total > 0 else 0
            self.url_progress_label.config(text=f"URL進捗: {completed}/{total} ({percentage}%)")

    def update_elapsed_time(self, elapsed_seconds):
        """経過時間を更新"""
        if hasattr(self, 'elapsed_time_label'):
            hours = int(elapsed_seconds // 3600)
            minutes = int((elapsed_seconds % 3600) // 60)
            seconds = int(elapsed_seconds % 60)
            self.elapsed_time_label.config(text=f"経過時間: {hours:02d}:{minutes:02d}:{seconds:02d}")

    def log(self, message, level="info", to_file_only=False):
        """ログ出力（ログエリアに表示）⭐非同期化でGUIブロッキング防止⭐"""
        if not to_file_only and hasattr(self, 'log_text'):
            # ⭐修正: root.after()で非同期実行してGUIスレッドブロッキングを防ぐ⭐
            def _log_to_gui():
                try:
                    timestamp = datetime.now().strftime("%H:%M:%S")
                    level_prefix = {
                        "info": "[INFO]",
                        "warning": "[WARN]",
                        "error": "[ERROR]",
                        "debug": "[DEBUG]"
                    }.get(level, "[INFO]")
                    
                    log_message = f"{timestamp} {level_prefix} {message}\n"
                    
                    self.log_text.config(state='normal')
                    self.log_text.insert(tk.END, log_message)
                    if self.auto_scroll_enabled:
                        self.log_text.see(tk.END)
                    self.log_text.config(state='disabled')
                except Exception as e:
                    print(f"[ログ出力エラー] {e}: {message}")
            
            # 非同期実行（GUIスレッドで実行）
            if hasattr(self.parent, 'root'):
                self.parent.root.after(0, _log_to_gui)
            else:
                _log_to_gui()  # フォールバック
        else:
            # フォールバック（ログエリアがない場合）
            print(f"[{level.upper()}] {message}")

    def update_url_background(self, url):
        """URLの背景色を状態に応じて更新（リアルタイム対応）"""
        if not url:
            return
        
        try:
            # ⭐修正: url_panelからurl_textを取得⭐
            if not hasattr(self.parent, 'url_panel') or not hasattr(self.parent.url_panel, 'url_text'):
                # url_panelがない場合は何もしない
                return
            
            # 正規化されたURLを取得
            # ⭐修正: parentからnormalize_urlを取得⭐
            if hasattr(self.parent, 'normalize_url'):
                normalized_url = self.parent.normalize_url(url)
            elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'normalize_url'):
                normalized_url = self.parent.downloader_core.normalize_url(url)
            else:
                normalized_url = url
            
            if not normalized_url:
                return

            # URLテキスト全体を取得（url_panelから）
            content = self.parent.url_panel.url_text.get("1.0", tk.END)
            lines = content.split('\n')
            
            # URLを含む行を検索（正規化URLでも検索）
            target_line = -1
            
            for i, line in enumerate(lines):
                line_stripped = line.strip()
                raw_url_part = line_stripped.split("(")[0].strip()  # マーカーを除いたURL部分
                # ⭐修正: parentからnormalize_urlを取得⭐
                if hasattr(self.parent, 'normalize_url'):
                    current_url = self.parent.normalize_url(raw_url_part)
                elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'normalize_url'):
                    current_url = self.parent.downloader_core.normalize_url(raw_url_part)
                else:
                    current_url = raw_url_part
                
                if current_url == normalized_url:
                    target_line = i + 1  # tkinterは1ベース
                    break
            
            if target_line == -1:
                return
            
            # ⭐修正: StateManagerから状態を取得⭐
            status = "pending"
            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                state_manager = self.parent.downloader_core.state_manager
                status = state_manager.get_url_status(normalized_url) or "pending"
            elif hasattr(self.parent, 'url_status'):
                status = self.parent.url_status.get(url, "pending")
            
            # 状態に応じた背景色を設定
            # ⭐修正: skippedのチェックをcompletedの前に配置（スキップ時は常に薄いグレー）⭐
            if status == "downloading":
                bg_color = "#FFFACD"  # 薄い黄色（DL中）
                tag_name = "downloading"
            elif status == "skipped":
                bg_color = "#F0F0F0"  # 薄いグレー（スキップ済み）- 優先度最高
                tag_name = "skipped"
            elif status in ["paused", "error"]:
                bg_color = "#FFE4E1"  # 薄い赤色（中断・エラー）
                tag_name = "paused_error"
            elif status == "completed":
                # ⭐修正: completedでも、スキップされたURLの場合は薄いグレーにする⭐
                # StateManagerで再度確認（completedに上書きされていても、スキップ状態を優先）
                if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                    actual_status = self.parent.downloader_core.state_manager.get_url_status(url)
                    if actual_status == 'skipped':
                        bg_color = "#F0F0F0"  # 薄いグレー（スキップ済み）
                        tag_name = "skipped"
                    else:
                        bg_color = "#E0F6FF"  # 薄い青色（完了）
                        tag_name = "completed"
                else:
                    bg_color = "#E0F6FF"  # 薄い青色（完了）
                    tag_name = "completed"
            else:
                # デフォルト（未処理）
                bg_color = "white"
                tag_name = "default"
            
            # タグを設定
            line_start = f"{target_line}.0"
            line_end = f"{target_line}.end"
            
            # 既存のタグを削除
            for tag in ["downloading", "paused_error", "completed", "skipped", "default"]:
                self.url_text.tag_remove(tag, line_start, line_end)
            
            # 新しいタグを適用
            self.url_text.tag_add(tag_name, line_start, line_end)
            self.url_text.tag_config(tag_name, background=bg_color)
            
            # 画面を強制更新
            self.url_text.update_idletasks()
            
        except Exception as e:
            self.log(f"URL背景色更新エラー: {e}", "warning")

    def update_progress_display(self, url, current, total, title_override=None, status_text_override=None, download_range_info=None):
        """プログレス表示を更新（％表示と予想時間付き）"""
        try:
            # ⭐追加: url_indexを最初に取得（すべてのupdate_current_progress呼び出しで使用）⭐
            url_index = None
            if hasattr(self.parent, 'current_url_index'):
                url_index = self.parent.current_url_index
            elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                url_index = self.parent.downloader_core.state_manager.get_current_url_index()
            
            # ⭐修正: progress_bars辞書のdownload_range_infoを更新（save_folderは保存しない）⭐
            if url:
                # 該当するURLのプログレスバーを検索してdownload_range_infoを更新（正規化URLで比較）
                if hasattr(self.parent, 'normalize_url'):
                    normalized_url = self.parent.normalize_url(url)
                else:
                    normalized_url = url
                # StateManagerから取得
                all_progress_bars = self._get_progress_bars()
                
                for url_idx, progress in all_progress_bars.items():
                    progress_url = progress.get('url', '')
                    if progress_url:
                        if hasattr(self.parent, 'normalize_url'):
                            normalized_progress_url = self.parent.normalize_url(progress_url)
                        else:
                            normalized_progress_url = progress_url
                        if normalized_progress_url == normalized_url or progress_url == url:
                            # ⭐修正: save_folderを保存しない（managed_foldersから動的に取得）⭐
                            # ⭐追加: ダウンロード範囲情報を更新⭐
                            if download_range_info:
                                progress['download_range_info'] = download_range_info.copy()
                                # ⭐修正: StateManagerにも保存⭐
                                if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                                    # StateManagerのprogress_barsを直接更新（download_range_infoはprogress_infoの一部）
                                    state_manager = self.parent.downloader_core.state_manager
                                    with state_manager._state_lock:
                                        if url_idx in state_manager.download_state.progress_bars:
                                            state_manager.download_state.progress_bars[url_idx]['download_range_info'] = download_range_info.copy()
                            break
            
            # タイトルを更新
            if title_override:
                self.update_progress_title(url, title_override, url_index=url_index)
            
            # プログレス表示を更新（％表示と予想時間付き）
            if status_text_override:
                # status_text_overrideが渡された場合は、それが既存の進捗情報を含む可能性があるため、そのまま使用
                # ただし、「状態:」で始まる場合は、update_current_progress()内で既存の進捗情報に追加される
                # ⭐修正: URLとdownload_range_infoとurl_indexを確実に渡す⭐
                self.update_current_progress(current, total, status_text_override, url, download_range_info=download_range_info, url_index=url_index)
            else:
                # デフォルトのステータステキストに％と時間を含める
                # ⭐修正: 既存の状態情報を保持するため、進捗情報のみを生成してupdate_current_progress()に渡す⭐
                # update_current_progress()内で既存の状態情報とダウンロード範囲情報が追加される
                if current > 0 and total > 0:
                    # 開始時間がない場合は現在時刻を設定
                    # ⭐修正: 既存のプログレスバーがある場合は、経過時間をリセットしない⭐
                    # 各プログレスバーごとの開始時間を使用
                    if url_index is not None and url_index >= 0:
                        existing_progress = self._get_progress_bar(url_index)
                        if existing_progress:
                            # elapsed_timeは辞書のキーとして取得（to_dict()で変換済み）
                            elapsed_time = existing_progress.get('elapsed_time', 0)
                            
                            # elapsed_timeが0または未設定の場合、start_timeから計算
                            if elapsed_time <= 0 and 'start_time' in existing_progress:
                                start_time = existing_progress.get('start_time')
                                if start_time and start_time > 0:
                                    # 一時停止時間を考慮した経過時間を計算
                                    paused_duration = existing_progress.get('paused_duration', 0)
                                    elapsed_time = time.time() - start_time - paused_duration
                                    elapsed_time = max(0, elapsed_time)
                        else:
                            # 既存のプログレスバーがない場合は、インスタンス変数を使用（フォールバック）
                            if not hasattr(self, 'current_download_start_time') or self.current_download_start_time is None:
                                self.current_download_start_time = time.time()
                            elapsed_time = time.time() - self.current_download_start_time
                    else:
                        # url_indexがない場合のフォールバック
                        elapsed_time = 0
                    
                    # ⭐防御的コーディング: elapsed_timeがNoneでないことを確認⭐
                    if elapsed_time is None:
                        elapsed_time = 0
                    
                    if current > 0 and elapsed_time > 0:
                        # 進捗率を計算
                        progress_percent = (current / total * 100) if total > 0 else 0
                        
                        estimated_total_time = elapsed_time * (total / current)
                        remaining_time = max(0, estimated_total_time - elapsed_time)
                        
                        elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                        remaining_str = f"{int(remaining_time//60):02d}:{int(remaining_time%60):02d}"
                        
                        # ⭐修正: 進捗情報のみを生成（状態情報はupdate_current_progress()内で追加される）⭐
                        status_text = f"ページ {current}/{total} {progress_percent:.1f}% | 経過: {elapsed_str} | 残り予想: {remaining_str}"
                    else:
                        # 進捗率を計算
                        progress_percent = (current / total * 100) if total > 0 else 0
                        status_text = f"ページ {current}/{total} {progress_percent:.1f}%"
                else:
                    status_text = f"ページ {current}/{total}"
                
                # ⭐修正: 進捗情報のみを渡す（状態情報はupdate_current_progress()内で追加される）⭐
                # statusパラメータを空文字列にすることで、update_current_progress()内で既存の状態情報を保持しつつ進捗情報を更新
                # ⭐修正: URLとdownload_range_infoを確実に渡す⭐
                self.update_current_progress(current, total, "", url, download_range_info=download_range_info)
            
        except Exception as e:
            self.log(f"プログレス表示更新エラー: {e}", "error")

    def set_url_status(self, url, status):
        """URL状態を設定（背景色も即座に更新）"""
        # StateManager経由で状態を設定
        if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
            self.parent.downloader_core.state_manager.set_url_status(url, status)
        # 背景色を即座に更新
        self.parent.root.after_idle(lambda: self.update_url_background(url))


    def _start_elapsed_time_timer(self):
        """経過時間タイマーを開始（後方互換性のため残置）"""
        # ⭐修正: StateManagerから開始時刻を取得⭐
        if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
            start_time = self.parent.downloader_core.state_manager.get_elapsed_time_start()
            if start_time:
                self._start_elapsed_time_timer_internal(start_time)
            else:
                # StateManagerに開始時刻がない場合は現在時刻を使用
                import time
                self._start_elapsed_time_timer_internal(time.time())
        else:
            # StateManagerがない場合は従来の方法
            import time
            self._start_elapsed_time_timer_internal(time.time())
    
    def _start_elapsed_time_timer_internal(self, start_time: float):
        """経過時間タイマーを開始（内部実装）"""
        try:
            if self.elapsed_time_timer_id:
                self.parent.root.after_cancel(self.elapsed_time_timer_id)
            
            # ⭐修正: last_elapsed_update_timeを初期化⭐
            if self.last_elapsed_update_time is None:
                self.last_elapsed_update_time = start_time if start_time else time.time()
            
            # 状態管理はStateManager経由（self.is_running、self.pausedは削除）
            # sequence_start_timeとlast_elapsed_update_timeもStateManagerで管理（必要に応じて）
            
            # ⭐修正: StateManagerから総経過時間を取得⭐
            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                state_manager = self.parent.downloader_core.state_manager
                self.total_elapsed_seconds = state_manager.get_total_elapsed_seconds()
            else:
                self.total_elapsed_seconds = 0
            
            def update_elapsed_time():
                try:
                    # StateManagerから状態を取得
                    if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                        state_manager = self.parent.downloader_core.state_manager
                        is_running = state_manager.is_download_running()
                        is_paused = state_manager.is_paused()
                    else:
                        is_running = False
                        is_paused = False
                    
                    if is_running:
                        current_time = time.time()
                        # ⭐修正: last_elapsed_update_timeが初期化されていない場合は現在時刻を設定⭐
                        if self.last_elapsed_update_time is None:
                            self.last_elapsed_update_time = current_time
                        
                        if not is_paused:
                            # 一時停止中でない場合のみ時間を進める
                            time_diff = current_time - self.last_elapsed_update_time
                            self.total_elapsed_seconds += time_diff
                            
                            # ⭐修正: StateManagerに経過時間を保存⭐
                            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                                state_manager = self.parent.downloader_core.state_manager
                                state_manager.add_elapsed_time(time_diff)
                        
                        self.last_elapsed_update_time = current_time
                        
                        # GUI更新
                        self.update_elapsed_time(self.total_elapsed_seconds)
                        
                        # 次の更新をスケジュール（1秒後）
                        self.elapsed_time_timer_id = self.parent.root.after(1000, update_elapsed_time)
                except Exception as e:
                    self.log(f"経過時間更新エラー: {e}", "error")
            
            # 最初の更新を開始
            update_elapsed_time()
        except Exception as e:
            self.log(f"経過時間タイマー開始エラー: {e}", "error")

    def _stop_elapsed_time_timer(self):
        """経過時間タイマーを停止"""
        try:
            if self.elapsed_time_timer_id:
                self.parent.root.after_cancel(self.elapsed_time_timer_id)
                self.elapsed_time_timer_id = None
        except Exception as e:
            self.log(f"タイマー停止エラー: {e}", "error")

    def reset_current_download_start_time(self):
        """現在のダウンロード開始時間をリセット"""
        self.current_download_start_time = None
    
    def show_current_progress_bar(self):
        """プログレスバー表示（ログエリアの上に）"""
        try:
            with self.progress_update_lock:
                # ⭐追加: 再開中フラグをチェック（再生成をスキップ）⭐
                if (hasattr(self.parent, 'downloader_core') and 
                    hasattr(self.parent.downloader_core, '_resume_in_progress') and
                    self.parent.downloader_core._resume_in_progress):
                    # 再開中は既存のプログレスバーを保持し、再生成をスキップ
                    self.parent.log("[DEBUG] 再開中のため、プログレスバー再生成をスキップ")
                    # ⭐重要: フラグを解除（既存プログレスバーがある場合でも解除）⭐
                    self.parent.downloader_core._resume_in_progress = False
                    self.progress_visible = True
                    return
                
                # ⭐追加: url_indexを取得（最優先）⭐
                url_index = None
                if hasattr(self.parent, 'current_url_index'):
                    url_index = self.parent.current_url_index
                elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                    url_index = self.parent.downloader_core.state_manager.get_current_url_index()
                
                # ⭐変更: ハッシュマップから直接取得⭐
                existing_progress = None
                if url_index is not None and url_index >= 0:
                    # url_indexで直接取得（StateManager経由）
                    existing_progress = self._get_progress_bar(url_index)
                
                # ⭐修正: 既存のプログレスバーがある場合でも、ダウンロードマネージャーがOFFの場合はメインウィンドウに表示⭐
                separate_window_enabled = hasattr(self.parent, 'progress_separate_window_enabled') and self.parent.progress_separate_window_enabled.get()
                
                if existing_progress:
                    # 既存のプログレスバーがある場合は、情報を保持
                    # ⭐追加: 再開中フラグが立っている場合は解除（二重解除でも問題ない）⭐
                    if (hasattr(self.parent, 'downloader_core') and 
                        hasattr(self.parent.downloader_core, '_resume_in_progress') and
                        self.parent.downloader_core._resume_in_progress):
                        self.parent.downloader_core._resume_in_progress = False
                    self.progress_visible = True
                    
                    # ⭐修正: ダウンロードマネージャーがOFFの場合は、メインウィンドウに表示⭐
                    if not separate_window_enabled:
                        self._show_latest_progress_in_main_window()
                    return
                
                # ⭐修正: 既存のプログレスバーがある場合は、開始時間をリセットしない⭐
                # 新規作成時のみ、開始時間を設定（既存の場合は辞書に保存されている開始時間を使用）
                if existing_progress:
                    # 既存のプログレスバーがある場合は、開始時間をリセットしない
                    if 'start_time' not in existing_progress or existing_progress['start_time'] is None:
                        existing_progress['start_time'] = time.time()
                else:
                    # 新規作成時のみ、インスタンス変数も設定（フォールバック用）
                    if not hasattr(self, 'current_download_start_time') or self.current_download_start_time is None:
                        self.current_download_start_time = time.time()
                # プログレスバーが非表示設定の場合でも新規DL時は表示する
                self.progress_visible = True
                
                # ⭐修正: タイトル取得を改善（既存のプログレスバーがある場合は、そのタイトルを優先）⭐
                # ⭐重要: HTML解析前でも既存のプログレスバーのタイトルを保持⭐
                title_text = "準備中..."
                if existing_progress:
                    saved_title = existing_progress['state'].get('title', '')
                    if saved_title and saved_title != "準備中...":
                        title_text = saved_title
                
                # ⭐削除: parent.current_gallery_titleへの依存を削除⭐
                # 既存のプログレスバーがない場合でも、parentから取得しない
                # HTML解析後にupdate_progress_title()で更新されるため、「準備中...」のままで問題ない
                
                # 現在のURLを取得
                url = ""
                if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'current_gallery_url'):
                    url = self.parent.downloader_core.current_gallery_url
                
                # ⭐修正: URLが空の場合は既存のプログレスバーを更新するか、何もしない⭐
                if not url:
                    # ⭐修正: URLが空の場合は、既存のプログレスバーをリセットしない⭐
                    # URLが空の場合は何もしない（既存のプログレスバーの状態を保持）
                    return  # URLが空の場合は新規作成しない
                
                # ⭐重要: スキップされたURLの場合は既存のプログレスバーを保持⭐
                if url and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                    # ⭐修正: StateManagerのメソッドを使用（高速読み取り用）⭐
                    url_status = self.parent.downloader_core.state_manager.get_url_status(url)
                    if url_status == 'skipped':
                        # ⭐削除: 不必要なDEBUGログを削除⭐
                        # 既存のプログレスバーを探して状態を更新（正規化URLで比較）
                        if hasattr(self.parent, 'normalize_url'):
                            normalized_url = self.parent.normalize_url(url)
                        else:
                            normalized_url = url
                        for url_idx, progress in self._get_progress_bars().items():
                            progress_url = progress.get('url', '')
                            if progress_url:
                                if hasattr(self.parent, 'normalize_url'):
                                    normalized_progress_url = self.parent.normalize_url(progress_url)
                                else:
                                    normalized_progress_url = progress_url
                                if normalized_progress_url == normalized_url or progress_url == url:
                                    progress['state']['status'] = "状態: スキップ"
                                    # StateManagerにも状態を更新
                                    if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                                        self.parent.downloader_core.state_manager.update_progress_bar_state(
                                            url_idx,
                                            status="状態: スキップ"
                                        )
                                break
                        return
                
                # 現在の総ページ数を取得（可能であれば）
                initial_total = 0
                if hasattr(self.parent, 'current_total_pages') and self.parent.current_total_pages:
                    initial_total = self.parent.current_total_pages
                    # プログレスバー初期化
                else:
                    # プログレスバー初期化: current_total_pages未設定
                    pass
                
                # ⭐削除: url_indexで見つからない場合はURLで検索（フォールバック）⭐
                # url_indexで見つからない場合は、新しいプログレスバーを作成するだけ
                # 既存のプログレスバーを更新してはいけない
                
                if existing_progress:
                    # ⭐修正: 既存のプログレスバーを更新（状態はリセットしない）⭐
                    # ⭐削除: 不必要なDEBUGログを削除⭐
                    
                    # ⭐追加: 既存の進捗情報を保持（リセットしない）⭐
                    existing_current = existing_progress['state'].get('current', 0)
                    existing_total = existing_progress['state'].get('total', 0)
                    existing_status = existing_progress['state'].get('status', '')
                    
                    # タイトルとoriginal_totalのみ更新（進捗情報は保持）
                    if title_text and title_text != "準備中...":
                        existing_progress['state']['title'] = title_text
                    if initial_total > 0 and existing_total == 0:
                        existing_progress['original_total'] = initial_total
                        existing_progress['state']['total'] = initial_total
                    elif initial_total > 0:
                        existing_progress['original_total'] = initial_total
                    
                    # URL情報も更新（正規化URLを保存）
                    if hasattr(self.parent, 'normalize_url'):
                        existing_progress['url'] = self.parent.normalize_url(url)
                    else:
                        existing_progress['url'] = url
                    
                    # ⭐追加: url_indexを更新⭐
                    if url_index is not None:
                        existing_progress['url_index'] = url_index
                    
                    progress_info = existing_progress
                    
                    # ⭐追加: 別ウィンドウ表示オプションをチェック（先に定義）⭐
                    separate_window_enabled = hasattr(self.parent, 'progress_separate_window_enabled') and self.parent.progress_separate_window_enabled.get()
                    
                    # ⭐追加: 既存のGUI要素がある場合は、それらを更新して再利用⭐
                    if (existing_progress.get('bar') and 
                        hasattr(existing_progress['bar'], 'winfo_exists') and 
                        existing_progress['bar'].winfo_exists() and
                        existing_progress.get('status') and
                        hasattr(existing_progress['status'], 'winfo_exists') and
                        existing_progress['status'].winfo_exists()):
                        # 既存のGUI要素を更新
                        if self.current_progress_bar != existing_progress['bar']:
                            self.current_progress_bar = existing_progress['bar']
                        if self.current_progress_status != existing_progress.get('status'):
                            self.current_progress_status = existing_progress.get('status')
                        if self.current_progress_title != existing_progress.get('title'):
                            self.current_progress_title = existing_progress.get('title')
                        if self.current_progress_frame != existing_progress.get('frame'):
                            self.current_progress_frame = existing_progress.get('frame')
                        
                        # 進捗情報を更新（GUI要素は破棄しない）
                        if existing_total > 0:
                            progress_value = (existing_current / existing_total) * 100
                            progress_value = max(0, min(100, progress_value))
                            try:
                                self.current_progress_bar['value'] = progress_value
                            except (tk.TclError, AttributeError):
                                pass
                        
                        if self.current_progress_status:
                            try:
                                self.current_progress_status.config(text=existing_status)
                            except (tk.TclError, AttributeError):
                                pass
                        
                        if self.current_progress_title and existing_progress['state'].get('title'):
                            try:
                                self.current_progress_title.config(text=existing_progress['state']['title'])
                            except (tk.TclError, AttributeError):
                                pass
                        
                        # 別ウィンドウ表示の場合は処理をスキップ
                        if separate_window_enabled:
                            return
                    else:
                        # ⭐追加: GUIウィジェットが存在しない場合は新しく作成⭐
                        # これにより、2つ目以降のURLでもメインウィンドウに表示される
                        if not separate_window_enabled:
                            # プログレスバーコンテナが存在しない場合のみ作成
                            if not self.progress_container or not hasattr(self.progress_container, 'winfo_exists') or not self.progress_container.winfo_exists():
                                self.progress_container = ttk.Frame(self.main_v_pane)
                            
                            # 共通メソッドを使用してプログレスバーGUI要素を生成
                            widgets = self._create_progress_bar_widgets(
                                self.progress_container, 
                                progress_info, 
                                url_index=url_index,
                                show_number=False,
                                is_main_window=True
                            )
                            
                            if widgets:
                                self.current_progress_frame = widgets['frame']
                                self.current_progress_bar = widgets['bar']
                                self.current_progress_status = widgets['status']
                                self.current_progress_title = widgets['title']
                                self.open_folder_btn = widgets['open_folder_btn']
                                
                                # プログレスバー情報を更新
                                progress_info['frame'] = self.current_progress_frame
                                progress_info['bar'] = self.current_progress_bar
                                progress_info['status'] = self.current_progress_status
                                progress_info['title'] = self.current_progress_title
                                progress_info['container'] = self.progress_container
                                
                                # StateManagerに更新を保存
                                if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                                    self.parent.downloader_core.state_manager.set_progress_bar(url_index, progress_info)
                                
                                # プログレスバーコンテナをmain_v_paneに追加（既に追加されていない場合のみ）
                                if self.main_v_pane and self.progress_container and self.progress_container not in self.main_v_pane.panes():
                                    # プログレスバーコンテナを最初に追加（上に配置）
                                    self.main_v_pane.add(self.progress_container, height=150, before=self.parent.bottom_pane)
                            return
                else:
                    # 新しいプログレスバー情報を作成
                    # ⭐重要: URLを正規化して保存⭐
                    if url and hasattr(self.parent, 'normalize_url'):
                        normalized_url = self.parent.normalize_url(url)
                    else:
                        normalized_url = url
                    progress_info = {
                        'url': normalized_url,  # 正規化されたURLを保存
                        'url_index': url_index,  # ⭐追加: url_indexを保存⭐
                        'frame': None,  # 後で設定
                        'bar': None,    # 後で設定
                        'status': None, # 後で設定
                        'title': None,  # 後で設定
                        'container': None,  # 後で設定
                        # ⭐削除: save_folderを保存しない（managed_foldersから動的に取得）⭐
                        'original_total': initial_total,  # プログレスバー表示用の元の総ページ数
                        'start_time': time.time(),  # ⭐追加: 各プログレスバーごとの開始時間を保存⭐
                        'elapsed_time': 0,  # ⭐追加: 経過時間を保存（初期値0）⭐
                        'state': {
                            'current': 0,
                            'total': 0,
                            'title': title_text,
                            'status': "状態: 待機中"
                        }
                    }
                    # StateManagerに保存（self.progress_barsは削除）
                    if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                        self.parent.downloader_core.state_manager.set_progress_bar(url_index, progress_info)
                    # ⭐最適化: 最新のアクティブなurl_indexを更新⭐
                    self.latest_active_index = url_index
                    # ⭐削除: 不必要なDEBUGログを削除⭐
                    
                    # ⭐修正: ダウンロードマネージャーがOFFの場合、即座にメインウィンドウに表示⭐
                    separate_window_enabled = hasattr(self.parent, 'progress_separate_window_enabled') and self.parent.progress_separate_window_enabled.get()
                    if not separate_window_enabled:
                        # メインウィンドウ表示時は最新のプログレスバーのみ表示（新規作成後、即座に表示）
                        # ⭐修正: 新規作成時はprogress_infoを直接使用してメインウィンドウに表示⭐
                        # プログレスバーコンテナが存在しない場合のみ作成
                        if not self.progress_container or not hasattr(self.progress_container, 'winfo_exists') or not self.progress_container.winfo_exists():
                            self.progress_container = ttk.Frame(self.main_v_pane)
                        
                        # 共通メソッドを使用してプログレスバーGUI要素を生成
                        widgets = self._create_progress_bar_widgets(
                            self.progress_container, 
                            progress_info, 
                            url_index=url_index,
                            show_number=False,
                            is_main_window=True
                        )
                        
                        if widgets:
                            self.current_progress_frame = widgets['frame']
                            self.current_progress_bar = widgets['bar']
                            self.current_progress_status = widgets['status']
                            self.current_progress_title = widgets['title']
                            self.open_folder_btn = widgets['open_folder_btn']
                            
                            # プログレスバー情報を更新
                            progress_info['frame'] = self.current_progress_frame
                            progress_info['bar'] = self.current_progress_bar
                            progress_info['status'] = self.current_progress_status
                            progress_info['title'] = self.current_progress_title
                            progress_info['container'] = self.progress_container
                            
                            # StateManagerに更新を保存
                            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                                self.parent.downloader_core.state_manager.set_progress_bar(url_index, progress_info)
                            
                            # プログレスバーコンテナをmain_v_paneに追加（既に追加されていない場合のみ）
                            if self.main_v_pane and self.progress_container and self.progress_container not in self.main_v_pane.panes():
                                # プログレスバーコンテナを最初に追加（上に配置）
                                self.main_v_pane.add(self.progress_container, height=150, before=self.parent.bottom_pane)
                        return
                
                # 別ウィンドウ表示オプションをチェック
                separate_window_enabled = hasattr(self.parent, 'progress_separate_window_enabled') and self.parent.progress_separate_window_enabled.get()
                
                if separate_window_enabled:
                    # サブウィンドウ表示時はメインウィンドウにプログレスバーを表示しない
                    self._show_progress_in_separate_window()
                    return  # 別ウィンドウ表示時はメインウィンドウのプログレスバー作成処理をスキップ
                
                # メインウィンドウ表示時は最新のプログレスバーのみ表示
                self._show_latest_progress_in_main_window()
                
        except Exception as e:
            self.log(f"プログレスバー表示エラー: {e}", "error")

    def _show_latest_progress_in_main_window(self):
        """メインウィンドウで最新のプログレスバーのみを表示（根本修正版）"""
        try:
            # ⭐根本修正: StateManagerから最新の"アクティブな"プログレスバーを取得⭐
            if not hasattr(self.parent, 'downloader_core') or not hasattr(self.parent.downloader_core, 'state_manager'):
                return
            
            state_manager = self.parent.downloader_core.state_manager
            progress_bars = state_manager.get_all_progress_bars()
            
            if not progress_bars:
                return
            
            # ⭐修正: ダウンロード中または待機中のプログレスバーから最新を取得⭐
            active_indices = []
            for idx, progress in progress_bars.items():
                # ⭐修正: ProgressBarオブジェクトの場合は属性アクセス、辞書の場合は.get()⭐
                if hasattr(progress, 'status'):
                    status = progress.status
                elif isinstance(progress, dict):
                    status = progress.get('status', '')
                else:
                    status = ''
                
                # ダウンロード中、待機中、中断中のいずれか
                if status in ['ダウンロード中', '待機中', '中断', 'downloading', 'pending', 'paused']:
                    active_indices.append(idx)
            
            # アクティブなものがない場合は、最大のインデックスを使用
            if not active_indices:
                latest_url_index = max(progress_bars.keys())
            else:
                latest_url_index = max(active_indices)
            
            # ⭐修正: _ensure_progress_bar_guiはStateManagerから最新情報を自動取得⭐
            # progress_info=Noneを渡すことで、メソッド内でStateManagerから取得される
            self._ensure_progress_bar_gui(latest_url_index, progress_info=None, is_main_window=True)
            
            # ⭐修正: プログレスバーコンテナを main_v_pane に追加⭐
            if self.progress_container and hasattr(self.progress_container, 'winfo_exists') and self.progress_container.winfo_exists():
                if self.main_v_pane and self.progress_container not in self.main_v_pane.panes():
                    # 下部ペインの前に挿入
                    self.main_v_pane.add(self.progress_container, height=150, before=self.parent.bottom_pane)
                    
        except Exception as e:
            self.log(f"[ERROR] _show_latest_progress_in_main_window: {e}", "error")
            import traceback
            traceback.print_exc()
            
            # プログレスバーコンテナをmain_v_paneに追加（既に追加されていない場合のみ）
            if self.main_v_pane and self.progress_container and self.progress_container not in self.main_v_pane.panes():
                # プログレスバーコンテナを最初に追加（上に配置）
                self.main_v_pane.add(self.progress_container, height=150, before=self.parent.bottom_pane)
            
            # クリーンアップフラグをリセット
            self.progress_cleanup_needed = False
            if hasattr(self.parent, 'downloader_core'):
                self.parent.downloader_core.progress_visible = True
                
        except Exception as e:
            self.log(f"プログレスバー表示エラー: {e}", "error")

    def _open_current_folder(self):
        """現在の作業フォルダを開く（managed_foldersから動的に取得）"""
        try:
            # ⭐修正: メインウィンドウに表示されているプログレスバーのURLからmanaged_foldersを取得⭐
            save_folder = None
            
            # 最新のプログレスバーのURLを取得
            latest_progress = None
            if self.latest_active_index is not None and self.latest_active_index >= 0:
                latest_progress = self._get_progress_bar(self.latest_active_index)
            else:
                # フォールバック: 最大のurl_indexを持つプログレスバーを取得
                progress_bars = self._get_progress_bars()
                if progress_bars:
                    progress_bars = self._get_progress_bars()
                    latest_url_index = max(progress_bars.keys()) if progress_bars else -1
                    latest_progress = progress_bars.get(latest_url_index) if latest_url_index >= 0 else None
            
            if latest_progress:
                url = latest_progress.get('url', '')
                if url:
                    if hasattr(self.parent, 'normalize_url'):
                        normalized_url = self.parent.normalize_url(url)
                    elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'normalize_url'):
                        normalized_url = self.parent.downloader_core.normalize_url(url)
                    else:
                        normalized_url = url
                    
                    if normalized_url and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'managed_folders') and normalized_url in self.parent.downloader_core.managed_folders:
                        save_folder = self.parent.downloader_core.managed_folders[normalized_url]
            
            # それでも見つからない場合は従来の方法を使用
            if not save_folder:
                if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'current_gallery_url'):
                    current_url = self.parent.downloader_core.current_gallery_url
                    if current_url:
                        if hasattr(self.parent, 'normalize_url'):
                            normalized_url = self.parent.normalize_url(current_url)
                        elif hasattr(self.parent.downloader_core, 'normalize_url'):
                            normalized_url = self.parent.downloader_core.normalize_url(current_url)
                        else:
                            normalized_url = current_url
                        
                        if normalized_url and hasattr(self.parent.downloader_core, 'managed_folders') and normalized_url in self.parent.downloader_core.managed_folders:
                            save_folder = self.parent.downloader_core.managed_folders[normalized_url]
                
                if not save_folder:
                    if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'current_save_folder'):
                        save_folder = self.parent.downloader_core.current_save_folder
                    elif hasattr(self.parent, 'current_save_folder'):
                        save_folder = self.parent.current_save_folder
                    elif hasattr(self.parent, 'folder_var'):
                        save_folder = self.parent.folder_var.get()
            
            if save_folder and os.path.exists(save_folder):
                self._open_specific_folder(save_folder)
            else:
                self.log("フォルダを開く機能が利用できません", "error")
        except Exception as e:
            self.log(f"フォルダを開くエラー: {e}", "error")
    
    def _open_gallery_url(self, url):
        """ギャラリーURLをブラウザで開く"""
        try:
            import webbrowser
            webbrowser.open(url)
            self.log(f"ギャラリーページを開きました: {url}", "info")
        except Exception as e:
            self.log(f"URLを開くエラー: {e}", "error")
    
    def _get_download_range_text(self, url=None):
        """ダウンロード範囲情報を取得して表示用テキストを返す"""
        try:
            # ⭐追加: URLが指定されていない場合は空文字列を返す⭐
            if not url:
                return ""
            
            # download_range_enabledの状態をチェック
            has_attr = hasattr(self.parent, 'download_range_enabled')
            is_enabled = self.parent.download_range_enabled.get() if has_attr else False
            
            # ダウンロード範囲オプションがONかどうかをチェック
            if not has_attr or not is_enabled:
                return ""
            
            # ダウンロード範囲モードを取得
            download_range_mode = "first_url_only"
            if hasattr(self.parent, 'download_range_mode'):
                download_range_mode = self.parent.download_range_mode.get()

            
            # 1行目のURLのみの場合、現在のURLが最初のURLかどうかをチェック
            # ⭐修正: "1行目のURLのみ"と"first_url_only"の両方をチェック⭐
            if download_range_mode == "first_url_only" or download_range_mode == "1行目のURLのみ":
                # 最初のURLを取得
                first_url = None
                if hasattr(self.parent, 'url_panel') and hasattr(self.parent.url_panel, 'get_first_url'):
                    first_url = self.parent.url_panel.get_first_url()
                elif hasattr(self.parent, 'url_panel') and hasattr(self.parent.url_panel, 'url_text'):
                    # フォールバック: URLテキストから最初の行を取得
                    try:
                        url_text = self.parent.url_panel.url_text
                        first_line = url_text.get("1.0", "1.end").strip()
                        if first_line:
                            # マーカーを除去
                            first_url = first_line.split("(")[0].strip()
                    except Exception:
                        pass

                
                if first_url:
                    normalized_url = self.parent.normalize_url(url) if hasattr(self.parent, 'normalize_url') else url
                    normalized_first_url = self.parent.normalize_url(first_url) if hasattr(self.parent, 'normalize_url') else first_url
                    # ⭐修正: 正規化URLで厳密に比較⭐
                    if normalized_url != normalized_first_url:
                        return ""  # 最初のURLでない場合は表示しない
                else:
                    return ""
            else:
                pass  # 全てのURLに適用

            
            # ダウンロード範囲の開始と終了を取得
            range_start = 0
            range_end = None
            
            if hasattr(self.parent, 'download_range_start'):
                start_val = self.parent.download_range_start.get()
                if start_val:
                    try:
                        range_start = int(start_val)
                    except (ValueError, TypeError):
                        range_start = 0
            
            if hasattr(self.parent, 'download_range_end'):
                end_val = self.parent.download_range_end.get()
                if end_val:
                    try:
                        range_end = int(end_val)
                    except (ValueError, TypeError):
                        range_end = None
            
            # 表示用テキストを生成
            if range_end is not None:
                result = f"ダウンロード範囲: {range_start}～{range_end}"
            else:
                result = f"ダウンロード範囲: {range_start}～∞"
            
            return result
                
        except Exception as e:
            self.log(f"[ERROR] _get_download_range_text exception: {e}", "error")
            import traceback
            self.log(f"[ERROR] Traceback: {traceback.format_exc()}", "error")
            return ""
    
    def _get_download_status(self, url=None):
        """現在のダウンロード状態を取得（詳細版）"""
        try:
            # ⭐修正: URLが指定されている場合はそのURLの状態を取得⭐
            target_url = url
            if not target_url and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'current_gallery_url'):
                target_url = self.parent.downloader_core.current_gallery_url
            
            # URLが指定されている場合は、そのURLの状態を優先的にチェック
            if target_url and hasattr(self.parent, 'url_status'):
                # URLを正規化して比較
                if hasattr(self.parent, 'normalize_url'):
                    normalized_target_url = self.parent.normalize_url(target_url)
                else:
                    normalized_target_url = target_url
                
                # 正規化URLで検索
                url_status = None
                for status_url, status in self.parent.url_status.items():
                    if hasattr(self.parent, 'normalize_url'):
                        normalized_status_url = self.parent.normalize_url(status_url)
                    else:
                        normalized_status_url = status_url
                    if normalized_status_url == normalized_target_url or status_url == target_url:
                        url_status = status
                        break
                
                if url_status:
                    # URL個別の状態を返す
                    if url_status == 'completed':
                        return "完了"
                    elif url_status == 'skipped':
                        return "スキップ済み"
                    elif url_status == 'error':
                        return "エラー"
                    elif url_status == 'incomplete':
                        return "未完了（画像スキップ）"
                    elif url_status == 'downloading':
                        return "ダウンロード中"
                    elif url_status == 'paused':
                        return "一時停止"
            
            # エラー状態をチェック（URL状態から）
            if hasattr(self.parent, 'url_status') and self.parent.url_status:
                # 現在のURLがエラー状態かチェック
                if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'current_gallery_url'):
                    current_url = self.parent.downloader_core.current_gallery_url
                    if current_url and current_url in self.parent.url_status:
                        if self.parent.url_status[current_url] == 'error':
                            # ⭐修正: エラー状態を「エラー」として返す⭐
                            return "エラー"
            
            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                state_manager = self.parent.downloader_core.state_manager
                
                # 中断状態チェック（より確実な判定）
                if state_manager.is_paused():
                    return "中断"
                
                # ダウンロード中チェック
                if state_manager.is_download_running():
                    # プログレスが0の場合は準備中
                    if hasattr(self.parent, 'downloader_core'):
                        current_progress = getattr(self.parent.downloader_core, 'current_progress', 0)
                        current_page = getattr(self.parent.downloader_core, 'current_page', 0)
                        if current_progress == 0 and current_page == 0:
                            return "準備中..."
                    # ⭐修正: ダウンロード中状態を「ダウンロード中」として返す⭐
                    return "ダウンロード中"
                
                # 全体の完了チェック
                if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, '_sequence_complete_executed'):
                    if self.parent.downloader_core._sequence_complete_executed:
                        return "完了"
            
            # デフォルト状態
            return "待機中"
            
        except Exception as e:
            # ⭐削除: 不必要なDEBUGログを削除⭐
            return "不明"
    
    def update_progress_status(self, status_type, details="", url=None, url_index=None):
        """プログレスバーの状態を明示的に更新（詳細情報を保持）"""
        try:
            # パフォーマンス最適化: 更新頻度制限
            current_time = time.time()
            update_key = f"{url_index}_{status_type}" if url_index is not None else status_type
            
            if update_key in self.last_status_update_time:
                if current_time - self.last_status_update_time[update_key] < self.status_update_interval:
                    return  # 更新間隔が短すぎる場合はスキップ
            
            self.last_status_update_time[update_key] = current_time
            
            with self.progress_update_lock:
                progress_bars = self._get_progress_bars()
                if not progress_bars:
                    return
                
                # ⭐修正: url_indexのみで検索（URL検索は削除）⭐
                target_progress = None
                
                # url_indexを取得
                if url_index is None:
                    if hasattr(self.parent, 'current_url_index'):
                        url_index = self.parent.current_url_index
                    elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                        url_index = self.parent.downloader_core.state_manager.get_current_url_index()
                
                if url_index is not None and url_index >= 0:
                    target_progress = self._get_progress_bar(url_index)
                
                # ⭐修正: url_indexが見つからない場合は更新しない⭐
                if not target_progress:
                    self.log(f"[WARNING] update_progress_status: url_index={url_index}のプログレスバーが見つかりません", "warning")
                    return
                
                # 既存の詳細情報を取得
                current = target_progress['state'].get('current', 0)
                total = target_progress['state'].get('total', 0)
                
                # ⭐修正: 時間情報を計算（既存の経過時間を保持、リセットしない）⭐
                # ⭐修正: 各プログレスバーごとの開始時間を使用⭐
                elapsed_time = 0
                # 既存のプログレスバーに保存されている経過時間を使用
                saved_elapsed_time = target_progress.get('elapsed_time', 0)
                if saved_elapsed_time > 0:
                    # 既存の経過時間を使用（リセットしない）
                    elapsed_time = saved_elapsed_time
                else:
                    # 開始時間から経過時間を計算
                    start_time = target_progress.get('start_time')
                    if start_time:
                        elapsed_time = time.time() - start_time
                        # 計算した経過時間を保存（次回使用するため）
                        target_progress['elapsed_time'] = elapsed_time
                    elif hasattr(self, 'current_download_start_time') and self.current_download_start_time:
                        # フォールバック: インスタンス変数を使用
                        elapsed_time = time.time() - self.current_download_start_time
                        # 計算した経過時間を保存（次回使用するため）
                        target_progress['elapsed_time'] = elapsed_time
                        # 開始時間も保存
                        target_progress['start_time'] = self.current_download_start_time
                
                    # 状態に応じたステータステキストを生成（詳細情報を含む）
                if status_type == "error":
                    if current > 0 and total > 0:
                        elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                        status_text = f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: エラー {details}" if details else f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: エラー"
                    else:
                        status_text = f"状態: エラー {details}" if details else "状態: エラー"
                elif status_type == "skipped":
                    if current > 0 and total > 0:
                        elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                        status_text = f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: スキップ {details}" if details else f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: スキップ"
                    else:
                        status_text = f"状態: スキップ {details}" if details else "状態: スキップ"
                elif status_type == "completed":
                    if current > 0 and total > 0:
                        elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                        status_text = f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: 完了"
                    else:
                        status_text = "状態: 完了"
                elif status_type == "incomplete":
                    if current > 0 and total > 0:
                        elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                        status_text = f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: 未完了（画像スキップ）"
                    else:
                        status_text = "状態: 未完了（画像スキップ）"
                elif status_type == "paused":
                    if current > 0 and total > 0:
                        elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                        status_text = f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: 一時停止"
                    else:
                        status_text = "状態: 一時停止"
                elif status_type == "interrupted":
                    if current > 0 and total > 0:
                        elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                        status_text = f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: 中断"
                    else:
                        status_text = "状態: 中断"
                else:
                    if current > 0 and total > 0:
                        elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                        status_text = f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: {status_type}"
                    else:
                        status_text = f"状態: {status_type}"
                
                # プログレスバーの状態を更新
                target_progress['state']['status'] = status_text
                # ⭐修正: 経過時間も保存（次回使用するため）⭐
                target_progress['elapsed_time'] = elapsed_time
                
                # ⭐修正: ttkウィジェットにはbgオプションがないため、スタイルを使用⭐
                # 背景色の更新はスキップ（ttkウィジェットはスタイルで制御する必要がある）
                # 必要に応じて、カスタムスタイルを定義して使用する
                
                # ⭐修正: 別ウィンドウのプログレスバーも即座に更新（完了状態も含む）⭐
                # ⭐重要: ダウンロードマネージャーが開いている場合は常に更新⭐
                if hasattr(self, 'separate_window') and self.separate_window and self.separate_window.winfo_exists():
                    if url_index is not None and url_index >= 0:
                        # ダウンロードマネージャーが開いている場合は更新
                        progress_info = {'state': {'current': current, 'total': total, 'status': status_text, 'title': target_progress['state'].get('title', '準備中...')}}
                        self._update_separate_window_progress_bar(url_index, progress_info)
                elif hasattr(self.parent, 'progress_separate_window_enabled') and self.parent.progress_separate_window_enabled.get():
                    # ⭐修正: url_indexを渡す（URLは削除）⭐
                    if url_index is not None and url_index >= 0:
                        self._update_separate_window_progress_immediate(current, total, status_text, url_index=url_index)
                    
        except Exception as e:
            self.log(f"プログレス状態更新エラー: {e}", "error")
    
    def update_progress_status_async(self, url, status_type, details="", url_index=None):
        """プログレスバーの状態を非同期的に更新（詳細情報を保持）"""
        def update_status():
            try:
                # パフォーマンス最適化: 更新頻度制限
                current_time = time.time()
                update_key = f"{url_index}_{status_type}" if url_index is not None else status_type
                
                if update_key in self.last_status_update_time:
                    if current_time - self.last_status_update_time[update_key] < self.status_update_interval:
                        return  # 更新間隔が短すぎる場合はスキップ
                
                self.last_status_update_time[update_key] = current_time
                
                with self.progress_update_lock:
                    if not self.progress_bars:
                        return
                    
                    # ⭐修正: url_indexのみで検索（URL検索は削除）⭐
                    target_progress = None
                    
                    # url_indexを取得
                    if url_index is None:
                        if hasattr(self.parent, 'current_url_index'):
                            url_index = self.parent.current_url_index
                        elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                            url_index = self.parent.downloader_core.state_manager.get_current_url_index()
                    
                    if url_index is not None and url_index >= 0:
                        target_progress = self._get_progress_bar(url_index)
                    
                    # url_indexが見つからない場合は更新しない
                    if not target_progress:
                        self.log(f"[WARNING] update_progress_status_async: url_index={url_index}のプログレスバーが見つかりません", "warning")
                        return
                    
                    # 既存の詳細情報を取得
                    current = target_progress['state'].get('current', 0)
                    total = target_progress['state'].get('total', 0)
                    
                    # 各プログレスバーごとの開始時間を使用
                    elapsed_time = 0
                    saved_elapsed_time = target_progress.get('elapsed_time', 0)
                    if saved_elapsed_time > 0:
                        # 既存の経過時間を使用
                        elapsed_time = saved_elapsed_time
                    else:
                        # 開始時間から経過時間を計算
                        start_time = target_progress.get('start_time')
                        if start_time:
                            elapsed_time = time.time() - start_time
                            target_progress['elapsed_time'] = elapsed_time
                        elif hasattr(self, 'current_download_start_time') and self.current_download_start_time:
                            # フォールバック: インスタンス変数を使用
                            elapsed_time = time.time() - self.current_download_start_time
                        
                        # 状態に応じたステータステキストを生成（詳細情報を含む）
                        if status_type == "error":
                            if current > 0 and total > 0:
                                elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                                status_text = f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: エラー {details}" if details else f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: エラー"
                            else:
                                status_text = f"状態: エラー {details}" if details else "状態: エラー"
                        elif status_type == "skipped":
                            if current > 0 and total > 0:
                                elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                                status_text = f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: スキップ {details}" if details else f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: スキップ"
                            else:
                                status_text = f"状態: スキップ {details}" if details else "状態: スキップ"
                        elif status_type == "completed":
                            if current > 0 and total > 0:
                                elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                                status_text = f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: 完了"
                            else:
                                status_text = "状態: 完了"
                        elif status_type == "paused":
                            if current > 0 and total > 0:
                                elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                                status_text = f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: 一時停止"
                            else:
                                status_text = "状態: 一時停止"
                        elif status_type == "interrupted":
                            if current > 0 and total > 0:
                                elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                                status_text = f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: 中断"
                            else:
                                status_text = "状態: 中断"
                        else:
                            if current > 0 and total > 0:
                                elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                                status_text = f"ページ {current}/{total} | 経過: {elapsed_str} | 状態: {status_type}"
                            else:
                                status_text = f"状態: {status_type}"
                        
                        # プログレスバーの状態を更新
                    target_progress['state']['status'] = status_text
                        
                    # ⭐修正: ttkウィジェットにはbgオプションがないため、スタイルを使用⭐
                    # 背景色の更新はスキップ（ttkウィジェットはスタイルで制御する必要がある）
                    # 必要に応じて、カスタムスタイルを定義して使用する
                    
                    # ⭐修正: 別ウィンドウのプログレスバーも即座に更新⭐
                    if hasattr(self.parent, 'progress_separate_window_enabled') and self.parent.progress_separate_window_enabled.get():
                        # ⭐修正: url_indexを渡す（URLは削除）⭐
                        if url_index is not None and url_index >= 0:
                            self._update_separate_window_progress_immediate(current, total, status_text, url_index=url_index)
            except Exception as e:
                self.log(f"プログレス状態更新エラー: {e}", "error")
        
        # 非同期実行
        self.parent.root.after(0, update_status)
    
    def _update_separate_window_status(self, status_text, url=None):
        """別ウィンドウのステータス表示を更新"""
        try:
            if not self.separate_window_progress_bars:
                return
            
            # ⭐修正: URL指定がある場合は該当するプログレスバーを検索⭐
            target_progress = None
            if url:
                # URLを正規化
                if hasattr(self.parent, 'normalize_url'):
                    normalized_url = self.parent.normalize_url(url)
                else:
                    normalized_url = url
                
                for progress in self.separate_window_progress_bars:
                    progress_url = progress.get('url', '')
                    if progress_url:
                        if hasattr(self.parent, 'normalize_url'):
                            normalized_progress_url = self.parent.normalize_url(progress_url)
                        else:
                            normalized_progress_url = progress_url
                    if normalized_progress_url == normalized_url or progress_url == url:
                        target_progress = progress
                        break
            
            # ⭐削除: URL検索で見つからない場合は最新を取得（フォールバック）⭐
            # URL検索で見つからない場合は更新しない
            if not target_progress:
                return
            
            # ステータスラベルを更新
            if (target_progress.get('status') and 
                hasattr(target_progress['status'], 'winfo_exists') and 
                target_progress['status'].winfo_exists()):
                target_progress['status'].config(text=status_text)
                
        except Exception as e:
            # エラーは無視
            pass
    
    def _open_specific_folder(self, folder_path):
        """指定されたフォルダを開く（安定性改善版）"""
        try:
            # ⭐修正: フォルダパスの検証を強化⭐
            if not folder_path:
                self.log("フォルダパスが指定されていません", "error")
                return
                
            # パスの正規化
            import os
            folder_path = os.path.normpath(folder_path)
            
            if os.path.exists(folder_path) and os.path.isdir(folder_path):
                # フォルダが存在する場合のみ開く
                if hasattr(self.parent, 'open_folder'):
                    # ⭐修正: open_folder()内でログが出力されるため、ここではログを出力しない⭐
                    self.parent.open_folder(folder_path)
                else:
                    # フォールバック: システムのデフォルトファイルマネージャーで開く
                    import subprocess
                    import platform
                    if platform.system() == "Windows":
                        os.startfile(folder_path)
                    elif platform.system() == "Darwin":  # macOS
                        subprocess.run(["open", folder_path])
                    else:  # Linux
                        subprocess.run(["xdg-open", folder_path])
                    # ⭐修正: open_folder()を使用しない場合のみログを出力⭐
                self.log(f"フォルダを開きました: {folder_path}", "info")
            else:
                self.log(f"フォルダが存在しません: {folder_path}", "error")
        except Exception as e:
            self.log(f"フォルダを開くエラー: {e}", "error")

    def _pause_download(self):
        """ダウンロードを中断"""
        try:
            if hasattr(self.parent, 'pause_download'):
                self.parent.pause_download()
                # ボタン状態を更新
                self._update_separate_window_button_states()
            else:
                self.log("中断機能が利用できません", "error")
        except Exception as e:
            self.log(f"中断エラー: {e}", "error")

    def _resume_download(self):
        """ダウンロードを再開"""
        try:
            if hasattr(self.parent, 'resume_download'):
                self.parent.resume_download()
                # ボタン状態を更新
                self._update_separate_window_button_states()
            else:
                self.log("再開機能が利用できません", "error")
        except Exception as e:
            self.log(f"再開エラー: {e}", "error")

    def _skip_current_download(self):
        """現在のダウンロードをスキップ"""
        try:
            if hasattr(self.parent, 'skip_current_download'):
                self.parent.skip_current_download()
                # ボタン状態を更新
                self._update_separate_window_button_states()
            else:
                self.log("スキップ機能が利用できません", "error")
        except Exception as e:
            self.log(f"スキップエラー: {e}", "error")

    def _restart_current_download(self):
        """現在のダウンロードをリスタート"""
        try:
            if hasattr(self.parent, 'restart_download'):
                self.parent.restart_download()
                # ボタン状態を更新
                self._update_separate_window_button_states()
            else:
                self.log("リスタート機能が利用できません", "error")
        except Exception as e:
            self.log(f"リスタートエラー: {e}", "error")

    def _update_separate_window_button_states(self):
        """サブウィンドウのボタンのグレーアウト状態を更新"""
        try:
            if not hasattr(self, 'separate_window_pause_btn') or not self.separate_window_pause_btn:
                return
                
            # StateManagerから状態を取得（メインウィンドウと同じ方法）
            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                is_running = self.parent.downloader_core.state_manager.is_download_running()
                is_paused = self.parent.downloader_core.state_manager.is_paused()
            else:
                # フォールバック: 直接の状態を確認
                is_running = hasattr(self.parent, 'is_running') and self.parent.is_running
                is_paused = hasattr(self.parent, 'paused') and self.parent.paused
            
            # 中断ボタン: 実行中でない場合、または既に中断中の場合は無効
            if self.separate_window_pause_btn.winfo_exists():
                if not is_running or is_paused:
                    self.separate_window_pause_btn.config(state='disabled')
                else:
                    self.separate_window_pause_btn.config(state='normal')
            
            # 再開ボタン: 中断中でない場合は無効
            if self.separate_window_resume_btn.winfo_exists():
                if is_paused:
                    self.separate_window_resume_btn.config(state='normal')
                else:
                    self.separate_window_resume_btn.config(state='disabled')
            
            # スキップボタン: 実行中でない場合は無効
            if hasattr(self, 'separate_window_skip_btn') and self.separate_window_skip_btn.winfo_exists():
                if is_running:
                    self.separate_window_skip_btn.config(state='normal')
                else:
                    self.separate_window_skip_btn.config(state='disabled')
            
            # リスタートボタン: 実行中でない場合は無効
            if hasattr(self, 'separate_window_restart_btn') and self.separate_window_restart_btn.winfo_exists():
                if is_running:
                    self.separate_window_restart_btn.config(state='normal')
                else:
                    self.separate_window_restart_btn.config(state='disabled')
                    
        except Exception as e:
            self.log(f"ボタン状態更新エラー: {e}", "error")

    def _update_separate_window_title(self, title, url=None, url_index=None):
        """サブウィンドウのタイトルを更新"""
        try:
            if not self.separate_window_progress_bars:
                return
                
            # ⭐修正: url_indexが指定されている場合は、そのプログレスバーのみ更新⭐
            if url_index is not None and url_index >= 0:
                target_progress = None
                for progress in self.separate_window_progress_bars:
                    if progress.get('url_index') == url_index:
                        target_progress = progress
                        break
                
                if target_progress:
                    if title:
                        # タイトルラベルの更新
                        if (target_progress.get('title') and 
                            hasattr(target_progress['title'], 'winfo_exists') and 
                            target_progress['title'].winfo_exists()):
                            try:
                                target_progress['title'].config(text=title)
                            except (tk.TclError, AttributeError):
                                pass
                        
                        # 状態情報も更新
                        if target_progress.get('state'):
                            # StateManagerにタイトルを保存
                            target_progress['state']['title'] = title
                            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                                self.parent.downloader_core.state_manager.update_progress_bar_state(
                                    url_index, 
                                    title=title
                                )
                        
                        # メインのプログレスバー情報も更新（StateManager経由）
                        progress_info = self._get_progress_bar(url_index)
                        if progress_info:
                            progress_info['title'] = title
                            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                                self.parent.downloader_core.state_manager.set_progress_bar(url_index, progress_info)
            return
            
            # ⭐削除: url_indexが指定されていない場合は何もしない（誤って他のプログレスバーのタイトルが更新されることを防ぐ）⭐
            
        except Exception as e:
            self.log(f"タイトル更新エラー: {e}", "error")


    def _create_separate_window(self):
        """別ウィンドウを作成"""
        try:
            # ⭐既存のウィンドウが存在する場合は再作成しない⭐
            if self.separate_window and self.separate_window.winfo_exists():
                # ⭐修正: lift()を削除して前面表示を防止⭐
                # self.separate_window.lift()  # この行を削除
                # アクティブ化を防止（フォーカスを取得しない）
                return
            
            # 既存のウィンドウを完全に破棄
            if self.separate_window:
                try:
                    self.separate_window.destroy()
                except:
                    pass
                self.separate_window = None
                self.separate_window_progress_bars = []
                # ⭐追加: ウィンドウを閉じた時にダウンロードマネージャーボタンの状態を更新⭐
                if hasattr(self.parent, 'options_panel') and hasattr(self.parent.options_panel, '_update_download_manager_button_state'):
                    self.parent.options_panel._update_download_manager_button_state()
            
            # 新しいウィンドウを作成
            self.separate_window = tk.Toplevel(self.parent.root)
            self.separate_window.title("ダウンロードマネージャー")
            
            # 保存された設定を読み込み
            saved_geometry = self._load_separate_window_settings()
            self.separate_window.geometry(saved_geometry)
            
            self.separate_window.protocol("WM_DELETE_WINDOW", self._on_separate_window_close)
            
            # ⭐修正: フォーカス制御を完全に削除⭐
            # 複雑なイベントハンドラーは逆効果
            # self.separate_window.transient(self.parent.root)
            # self.separate_window.attributes('-topmost', False)
            # イベントハンドラーも削除
            # self.separate_window.bind("<FocusIn>", prevent_focus)
            # self.separate_window.bind("<Map>", prevent_focus)
            # self.separate_window.bind("<Button-1>", prevent_focus)
            
            # ヘッダーエリア（固定）
            header_frame = ttk.Frame(self.separate_window)
            header_frame.pack(fill="x", padx=5, pady=5)
            
            # 左側のコントロールボタン
            left_controls = ttk.Frame(header_frame)
            left_controls.pack(side="left", anchor="w")
            
            # 中断・再開ボタン
            self.separate_window_pause_btn = ttk.Button(left_controls, text="中断", 
                                                      command=self._pause_download, width=8)
            self.separate_window_pause_btn.pack(side="left", padx=(0, 5))
            
            self.separate_window_resume_btn = ttk.Button(left_controls, text="再開", 
                                                       command=self._resume_download, width=8)
            self.separate_window_resume_btn.pack(side="left", padx=(0, 5))
            
            # ⭐追加: GUI更新ボタン（再開ボタンの右側）⭐
            self.separate_window_refresh_btn = ttk.Button(left_controls, text="GUI更新", 
                                                       command=self._refresh_gui_state, width=8)
            self.separate_window_refresh_btn.pack(side="left", padx=(0, 5))
            
            # 右側のコントロールボタン
            right_controls = ttk.Frame(header_frame)
            right_controls.pack(side="right", anchor="e")
            
            # リスタート・スキップボタン（配置を逆にする）
            # ⭐リスタートボタン⭐
            self.separate_window_restart_btn = ttk.Button(right_controls, text="リスタート", 
                                                        command=self._restart_current_download, width=8)
            self.separate_window_restart_btn.pack(side="left", padx=(0, 5))
            
            # ⭐スキップボタン⭐
            self.separate_window_skip_btn = ttk.Button(right_controls, text="スキップ", 
                                                     command=self._skip_current_download, width=8)
            self.separate_window_skip_btn.pack(side="left", padx=(0, 5))
            
            # ⭐オートスクロールボタン（メインウィンドウのダウンロードマネージャーボタンと同じスタイル）⭐
            # オートスクロールボタン
            self.separate_window_autoscroll_btn = tk.Button(right_controls, text="オートスクロール", 
                                                           command=self._toggle_autoscroll, width=12,
                                                           relief="raised", bg="SystemButtonFace")
            self.separate_window_autoscroll_btn.pack(side="left", padx=(0, 5))
            
            # メインエリア（スクロール可能）
            main_frame = ttk.Frame(self.separate_window)
            main_frame.pack(fill="both", expand=True, padx=5, pady=(0, 5))
            
            # スクロール可能なフレーム
            canvas = tk.Canvas(main_frame)
            scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="n")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # スクロール可能フレームの幅をウィンドウ幅に合わせる
            def configure_scroll_region(event):
                try:
                    canvas.configure(scrollregion=canvas.bbox("all"))
                    # スクロール可能フレームの幅をキャンバス幅に合わせる
                    canvas_width = canvas.winfo_width()
                    if canvas_width > 1:  # キャンバスが初期化されている場合
                        # 全てのウィンドウアイテムの幅を更新
                        for item in canvas.find_all():
                            if canvas.type(item) == "window":
                                canvas.itemconfig(item, width=canvas_width)
                except Exception as e:
                    pass  # エラーは無視
                
            canvas.bind('<Configure>', configure_scroll_region)
            
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            self.separate_window_canvas = canvas
            self.separate_window_scrollable_frame = scrollable_frame
            
            # ボタンのグレーアウト状態を初期化
            self._update_separate_window_button_states()
            
            # ⭐重要: ダウンロードマネージャーボタンの状態を更新⭐
            if hasattr(self.parent, 'options_panel'):
                self.parent.options_panel._update_download_manager_button_state()
            
            # ⭐修正: ダウンロードマネージャー起動時に既存の全てのダウンロード情報を保存してる辞書を読み出してプログレスバーに成型して表示⭐
            # 条件に関係なく、常に既存のプログレスバーを再構築
            self._rebuild_all_progress_bars_in_separate_window()
            
            # ⭐追加: ダウンロードマネージャー起動時に最新のステータスを辞書から読み取ってGUIに更新⭐
            self._refresh_all_progress_bars_status_in_separate_window()
            
            # ⭐追加: メインウィンドウのプログレスバーを非表示にする（排他表示）⭐
            self.hide_current_progress_bar()
                
        except Exception as e:
            self.log(f"別ウィンドウ作成エラー: {e}", "error")
    
    def _refresh_gui_state(self):
        """GUI状態を更新（ダウンロードマネージャー内のボタンから呼び出し）"""
        try:
            # ダウンロードマネージャー内のプログレスバーを更新
            self._refresh_all_progress_bars_status_in_separate_window()
            # ボタンの状態を更新
            self._update_separate_window_button_states()
            # メインウィンドウのプログレスバーも更新（ダウンロードマネージャーがOFFの場合）
            if not (hasattr(self.parent, 'progress_separate_window_enabled') and self.parent.progress_separate_window_enabled.get()):
                self._show_latest_progress_in_main_window()
            
            # ⭐追加: フォルダボタンの状態を更新⭐
            self._update_folder_buttons_state()
            
            self.parent.log("GUI状態を更新しました", "info")
        except Exception as e:
            self.log(f"GUI状態更新エラー: {e}", "error")
    
    def _update_folder_buttons_state(self):
        """フォルダボタンの状態を更新（保存ディレクトリが設定されている場合に有効化）"""
        try:
            if not hasattr(self.parent, 'downloader_core') or not hasattr(self.parent.downloader_core, 'managed_folders'):
                return
            
            managed_folders = self.parent.downloader_core.managed_folders
            if not managed_folders:
                return
            
            # ダウンロードマネージャー内のプログレスバーのフォルダボタンを更新
            if hasattr(self, 'separate_window_progress_bars'):
                for sep_progress in self.separate_window_progress_bars:
                    if 'open_folder_btn' in sep_progress and 'url' in sep_progress:
                        url = sep_progress.get('url', '')
                        if url:
                            normalized_url = self.parent.normalize_url(url) if hasattr(self.parent, 'normalize_url') else url
                            if normalized_url in managed_folders:
                                save_folder = managed_folders[normalized_url]
                                btn = sep_progress['open_folder_btn']
                                if btn and hasattr(btn, 'winfo_exists') and btn.winfo_exists():
                                    # ⭐修正: 保存ディレクトリが削除されている場合はグレーアウト⭐
                                    if save_folder and os.path.exists(save_folder):
                                        def make_open_cmd(folder_path):
                                            return lambda: self._open_specific_folder(folder_path)
                                        btn.config(state="normal", command=make_open_cmd(save_folder))
                                    else:
                                        btn.config(state="disabled")
            
            # メインウィンドウのプログレスバーのフォルダボタンを更新
            if hasattr(self, 'current_progress_frame') and self.current_progress_frame:
                # 最新のプログレスバー情報を取得
                if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                    state_manager = self.parent.downloader_core.state_manager
                    if self.latest_active_index is not None and self.latest_active_index >= 0:
                        progress_info = state_manager.get_progress_bar(self.latest_active_index)
                        if progress_info and 'url' in progress_info:
                            url = progress_info.get('url', '')
                            if url:
                                normalized_url = self.parent.normalize_url(url) if hasattr(self.parent, 'normalize_url') else url
                                if normalized_url in managed_folders:
                                    save_folder = managed_folders[normalized_url]
                                    if save_folder and os.path.exists(save_folder):
                                        # メインウィンドウのプログレスバーにフォルダボタンがある場合は更新
                                        # （メインウィンドウのプログレスバーには通常フォルダボタンがないため、ここではスキップ）
                                        pass
        except Exception as e:
            self.log(f"フォルダボタン状態更新エラー: {e}", "error")
    
    def _refresh_all_progress_bars_status_in_separate_window(self):
        """ダウンロードマネージャー内の全てのプログレスバーのステータスを辞書から読み取ってGUIに更新"""
        try:
            if not self.separate_window or not self.separate_window.winfo_exists():
                return
            
            if not hasattr(self.parent, 'downloader_core') or not hasattr(self.parent.downloader_core, 'state_manager'):
                return
            
            state_manager = self.parent.downloader_core.state_manager
            all_progress_bars = state_manager.get_all_progress_bars()
            
            for url_index, progress_info in all_progress_bars.items():
                # 既存のプログレスバーを検索
                for sep_progress in self.separate_window_progress_bars:
                    if sep_progress.get('url_index') == url_index:
                        # StateManagerから最新のプログレスバー情報を取得
                        latest_progress = state_manager.get_progress_bar(url_index)
                        if latest_progress:
                            # ⭐修正: プログレスバー全体を更新（ステータス以外も含む）⭐
                            self._update_separate_window_progress_bar(url_index, latest_progress)
                        break
        except Exception as e:
            self.log(f"ダウンロードマネージャーのステータス更新エラー: {e}", "error")
    
    def _refresh_all_progress_bars_status_in_main_window(self):
        """メインウィンドウの全てのプログレスバーのステータスを辞書から読み取ってGUIに更新"""
        try:
            if not hasattr(self.parent, 'downloader_core') or not hasattr(self.parent.downloader_core, 'state_manager'):
                return
            
            state_manager = self.parent.downloader_core.state_manager
            all_progress_bars = state_manager.get_all_progress_bars()
            
            # ⭐修正: 最新のアクティブなプログレスバーを検索（完了していないものから）⭐
            latest_url_index = -1
            latest_progress = None
            
            # 完了していないプログレスバーの中で最大のurl_indexを取得
            active_indices = [
                idx for idx, progress in all_progress_bars.items()
                if not self._is_progress_completed(progress)
            ]
            
            if active_indices:
                latest_url_index = max(active_indices)
                latest_progress = state_manager.get_progress_bar(latest_url_index)
            elif all_progress_bars:
                # 全て完了している場合は、最大のurl_indexを取得（表示用）
                latest_url_index = max(all_progress_bars.keys())
                latest_progress = state_manager.get_progress_bar(latest_url_index)
            
            # latest_active_indexを更新
            if latest_url_index >= 0:
                self.latest_active_index = latest_url_index
            
            # 最新のプログレスバーのステータスを更新
            if latest_progress and latest_url_index >= 0:
                # ⭐修正: StateManagerから最新の情報を取得してGUIに反映⭐
                self._update_main_window_progress_bar(latest_url_index, latest_progress)
        except Exception as e:
            self.log(f"メインウィンドウのステータス更新エラー: {e}", "error")

    def _on_separate_window_close(self):
        """別ウィンドウが閉じられた時の処理"""
        try:
            # ウィンドウ設定を保存
            self._save_separate_window_settings()
            
            if self.separate_window:
                self.separate_window.destroy()
            self.separate_window = None
            self.separate_window_progress_bars = []
            
            # ⭐追加: ダウンロードマネージャーをOFFにして、メインウィンドウにプログレスバーを表示⭐
            if hasattr(self.parent, 'progress_separate_window_enabled'):
                self.parent.progress_separate_window_enabled.set(False)
            
            # ⭐重要: ダウンロードマネージャーボタンの状態を更新⭐
            if hasattr(self.parent, 'options_panel'):
                self.parent.options_panel._update_download_manager_button_state()
            
            # ⭐追加: メインウィンドウに現在DL中のプログレスバーのみを表示⭐
            # ⭐修正: ダウンロードマネージャー停止時に最新のステータスを辞書から読み取ってGUIに更新⭐
            self._refresh_all_progress_bars_status_in_main_window()
            self._show_latest_progress_in_main_window()
                
        except Exception as e:
            self.log(f"別ウィンドウ閉鎖エラー: {e}", "error")
    
    def _save_separate_window_settings(self):
        """別ウィンドウの設定を保存（無効化）"""
        # メインウィンドウ経由で保存されるため、ここでは何もしない
        pass
    
    def _load_separate_window_settings(self):
        """別ウィンドウの設定を読み込み"""
        try:
            import json
            import os
            settings_file = "ehd_settings.json"
            
            if os.path.exists(settings_file):
                with open(settings_file, 'r', encoding='utf-8') as f:
                    unified_settings = json.load(f)
                
                download_manager_settings = unified_settings.get('download_manager', {})
                geometry = download_manager_settings.get('window_geometry', '700x800')
                
                return geometry
        except Exception as e:
            self.log(f"別ウィンドウ設定読み込みエラー: {e}", "error")
        
        return '700x800'  # デフォルト値
    
    def _toggle_autoscroll(self):
        """オートスクロールのON/OFFを切り替え"""
        self.auto_scroll_enabled = not self.auto_scroll_enabled
        
        if self.auto_scroll_enabled:
            # ON状態: 濃い灰色（メインウィンドウのダウンロードマネージャーボタンと同じスタイル）
            self.separate_window_autoscroll_btn.configure(
                bg="#808080",  # 濃い灰色
                fg="white",
                relief="raised"
            )
            self.log("オートスクロールを有効にしました", "info")
        else:
            # OFF状態: 通常の背景色
            self.separate_window_autoscroll_btn.configure(
                bg="SystemButtonFace",
                fg="black",
                relief="raised"
            )
            self.log("オートスクロールを無効にしました", "info")
    
    def _auto_scroll_to_bottom(self):
        """最下部に自動スクロール（遅延なし）"""
        if self.auto_scroll_enabled and self.separate_window_canvas:
            try:
                # 遅延なしで即座にスクロール
                self.separate_window_canvas.yview_moveto(1.0)
            except Exception as e:
                self.log(f"オートスクロールエラー: {e}", "error")
    
    def _perform_auto_scroll(self):
        """実際のスクロール処理を実行（使用されなくなる）"""
        # このメソッドは使用されなくなる
        pass

    def _show_progress_in_separate_window(self, title="準備中..."):
        """別ウィンドウでプログレスバーを表示"""
        try:
            # 別ウィンドウを作成（既に存在する場合は再作成しない）
            window_created = False
            if not self.separate_window or not self.separate_window.winfo_exists():
                self._create_separate_window()
                window_created = True
            
            if self.separate_window is None:
                return
            
            # ⭐修正: ウィンドウが新規作成された場合は再構築、そうでない場合は新しいもののみ追加⭐
            if window_created:
                # ウィンドウが新規作成された場合は全て再構築
                self._rebuild_all_progress_bars_in_separate_window()
            else:
                # 既存のウィンドウの場合は、未生成のプログレスバーを一括生成
                self._display_all_progress_bars_in_separate_window()
            
        except Exception as e:
            self.log(f"別ウィンドウプログレスバー表示エラー: {e}", "error")

    def _display_all_progress_bars_in_separate_window(self):
        """全てのプログレスバーをサブウィンドウに表示"""
        try:
            # ⭐修正: ウィンドウが再作成された場合は全て再構築、そうでない場合は新しいもののみ追加⭐
            # 既存のプログレスバー数を取得
            current_count = len(self.separate_window_progress_bars)
            new_count = len(self._get_progress_bars())
            
            # ウィンドウが再作成された場合（separate_window_progress_barsが空）は全て再構築
            if current_count == 0 and new_count > 0:
                self._rebuild_all_progress_bars_in_separate_window()
            else:
                # 新しいプログレスバーのみを追加（既存のものは削除しない）
                # ⭐変更: ハッシュマップベースでは、separate_window_progress_barsに存在しないurl_indexのプログレスバーを追加⭐
                existing_url_indices = set()
                for sep_progress in self.separate_window_progress_bars:
                    sep_url_index = sep_progress.get('url_index')
                    if sep_url_index is not None:
                        existing_url_indices.add(sep_url_index)
                
                # ⭐修正: StateManagerから取得を試みる⭐
                if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                    all_progress_bars = self.parent.downloader_core.state_manager.get_all_progress_bars()
                else:
                    # フォールバック: ローカルのprogress_barsから取得
                    all_progress_bars = self._get_progress_bars()
                
                for url_index in sorted(all_progress_bars.keys()):
                    if url_index not in existing_url_indices:
                        progress_info = all_progress_bars[url_index]
                        # プログレスバー{url_index+1}を作成中
                        self._create_progress_bar_in_separate_window_from_info(progress_info, url_index)
                
        except Exception as e:
            self.log(f"全プログレスバー表示エラー: {e}", "error")
    
    def _rebuild_all_progress_bars_in_separate_window(self):
        """progress_bars辞書から全てのプログレスバーを再構築（ハッシュマップベースでは保持数制限は不要）"""
        try:
            if not self.separate_window or not self.separate_window.winfo_exists():
                return
            
            # ⭐重要: 既存のプログレスバーを全て削除⭐
            for separate_progress in self.separate_window_progress_bars:
                try:
                    if separate_progress.get('frame') and separate_progress['frame'].winfo_exists():
                        separate_progress['frame'].destroy()
                except:
                    pass
            
            # 配列をクリア
            self.separate_window_progress_bars = []
            
            # StateManagerから取得
            all_progress_bars = self._get_progress_bars()
            
            # ⭐修正: progress_bars辞書が空の場合はログを出力⭐
            if not all_progress_bars:
                # ⭐削除: 不必要なDEBUGログを削除⭐
                return
            
            # ⭐修正: StateManagerから全てのプログレスバーを取得して再構築⭐
            # ハッシュマップベースでは保持数制限は不要（1万件以上保存可能）
            # url_index順にソートして処理
            for url_index in sorted(all_progress_bars.keys()):
                progress_info = all_progress_bars[url_index]
                self._create_progress_bar_in_separate_window_from_info(progress_info, url_index)
            
            # スクロール領域を更新
            if hasattr(self, 'separate_window_canvas'):
                self.separate_window_canvas.update_idletasks()
                self.separate_window_canvas.configure(scrollregion=self.separate_window_canvas.bbox("all"))
            
            # オートスクロールが有効な場合は最下部にスクロール
            if self.auto_scroll_enabled:
                self._auto_scroll_to_bottom()
            
            # ⭐追加: デバッグログ⭐
            # ⭐削除: 不必要なDEBUGログを削除⭐
                
        except Exception as e:
            self.log(f"プログレスバー再構築エラー: {e}", "error")
            import traceback
            self.log(f"トレースバック: {traceback.format_exc()}", "error")

    def _create_progress_bar_in_separate_window_from_info(self, progress_info, index):
        """プログレスバー情報からサブウィンドウ用プログレスバーを作成"""
        try:
            # ⭐修正: separate_window_scrollable_frameが存在するか確認⭐
            if not hasattr(self, 'separate_window_scrollable_frame') or not self.separate_window_scrollable_frame:
                self.log("separate_window_scrollable_frameが存在しません。ダウンロードマネージャーウィンドウが正しく初期化されていない可能性があります。", "error")
                return
            # ⭐修正: タイトル取得を改善（progress_info['title']を優先、次にparentから取得）⭐
            title = progress_info.get('title', '')
            
            # タイトルが空の場合、まずparentから取得を試みる（フォルダ名より優先）
            if not title or title == "準備中...":
                if hasattr(self.parent, 'current_gallery_title') and self.parent.current_gallery_title:
                    title = self.parent.current_gallery_title
                elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'current_gallery_title'):
                    title = self.parent.downloader_core.current_gallery_title
            
            # それでもタイトルが空の場合のみ、フォルダ名を使用（最後の手段）
            if not title or title == "準備中...":
                url = progress_info.get('url', '')
                if url:
                    # ⭐追加: 完了済みのプログレスバーの場合、managed_foldersからフォルダ名を取得してタイトルとして使用⭐
                    if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'managed_folders'):
                        normalized_url = self.parent.normalize_url(url) if hasattr(self.parent, 'normalize_url') else url
                        if normalized_url in self.parent.downloader_core.managed_folders:
                            save_folder = self.parent.downloader_core.managed_folders[normalized_url]
                            if save_folder:
                                # フォルダ名からタイトルを推測（最後のディレクトリ名を使用）
                                # ⭐修正: osは既にインポートされているため、再インポート不要⭐
                                folder_name = os.path.basename(save_folder)
                                if folder_name:
                                    title = folder_name
            
            # それでもタイトルが空の場合は「準備中...」をデフォルト表示
            if not title:
                title = "準備中..."
            
            # ⭐修正: 保存フォルダの情報を動的に取得（managed_foldersから）⭐
            # progress_infoのURLを使ってmanaged_foldersから取得
            url = progress_info.get('url', '')
            save_folder = ""
            if url:
                if hasattr(self.parent, 'normalize_url'):
                    normalized_url = self.parent.normalize_url(url)
                elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'normalize_url'):
                    normalized_url = self.parent.downloader_core.normalize_url(url)
                else:
                    normalized_url = url
                
                if normalized_url and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'managed_folders') and normalized_url in self.parent.downloader_core.managed_folders:
                    save_folder = self.parent.downloader_core.managed_folders[normalized_url] or ''
            
            # ⭐削除: フォールバック処理を削除（current_gallery_urlを使用しない）⭐
            
            # ⭐プログレスバーフレームを作成（連番を表示）⭐
            progress_number = index + 1  # 1から始まる連番
            progress_frame = ttk.LabelFrame(self.separate_window_scrollable_frame, text=f"ダウンロード進捗 ({progress_number})")
            
            # 縦並びで追加
            progress_frame.pack(fill="x", expand=True, padx=5, pady=2)
            
            # ヘッダーフレーム（タイトルと保存フォルダを開くボタン）
            header_frame = ttk.Frame(progress_frame)
            header_frame.pack(fill="x", padx=5, pady=2)
            
            # ⭐保存フォルダを開くボタン（常に作成、後で更新可能に）⭐
            open_folder_btn = ttk.Button(header_frame, text="📁", width=3, state="disabled")
            open_folder_btn.pack(side="right", anchor="e", padx=(5, 0))
            
            # ⭐修正: progress_infoへの参照を保存（変数参照方式）⭐
            progress_info['open_folder_btn'] = open_folder_btn
            
            # ⭐修正: フォルダボタンのcommandで、managed_foldersから動的に取得⭐
            def get_folder_from_managed_folders(progress_info):
                """progress_infoのURLを使ってmanaged_foldersからフォルダを取得して開く"""
                url = progress_info.get('url', '')
                if url:
                    if hasattr(self.parent, 'normalize_url'):
                        normalized_url = self.parent.normalize_url(url)
                    elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'normalize_url'):
                        normalized_url = self.parent.downloader_core.normalize_url(url)
                    else:
                        normalized_url = url
                    
                    if normalized_url and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'managed_folders') and normalized_url in self.parent.downloader_core.managed_folders:
                        folder = self.parent.downloader_core.managed_folders[normalized_url]
                        if folder and os.path.exists(folder):
                            self._open_specific_folder(folder)
                        else:
                            self.log("フォルダが見つかりません", "error")
                    else:
                        self.log("フォルダ情報が見つかりません", "error")
                else:
                    self.log("URL情報が見つかりません", "error")
            
            # フォルダが存在する場合はボタンを有効化
            if save_folder and os.path.exists(save_folder):
                open_folder_btn.config(state="normal", command=lambda pi=progress_info: get_folder_from_managed_folders(pi))
                # ToolTipを追加
                from gui.components.options_panel import ToolTip
                ToolTip(open_folder_btn, "保存フォルダを開く")
            else:
                # ToolTipを追加（無効状態でも）
                from gui.components.options_panel import ToolTip
                ToolTip(open_folder_btn, "保存フォルダ（準備中）")
            
            # タイトル表示（ハイパーリンク化、「準備中...」は表示しない）
            title_label = tk.Label(header_frame, text=title, 
                                 fg="black", cursor="hand2", font=("Arial", 9))
            title_label.pack(side="left", anchor="w", padx=(0, 10))
            
            # ⭐修正: URLを確実に保存（progress_infoから直接取得、上書きしない）⭐
            url = progress_info.get('url', '')
            if not url:
                # フォールバック: downloader_coreから取得（最新のプログレスバーのみ）
                # ⭐変更: ハッシュマップベースでは、latest_active_indexと比較⭐
                if (self.latest_active_index is not None and 
                    index == self.latest_active_index and 
                    hasattr(self.parent, 'downloader_core')):
                    url = getattr(self.parent.downloader_core, 'current_gallery_url', '')
            
            # ⭐重要: URL情報を確実に保存（上書きされないように）⭐
            if url:
                progress_info['url'] = url
            
            # ⭐修正: クリックイベントをバインド（URLとタイトルが両方存在する場合のみ）⭐
            # ⭐重要: クロージャでURLを固定（最新のURLで上書きされないように）⭐
            if url and title and title != "準備中...":
                # ⭐修正: クロージャでURLを固定（progress_infoから直接取得）⭐
                def create_open_url_handler(fixed_url):
                    def open_url_handler(event):
                        self._open_gallery_url(fixed_url)
                    return open_url_handler
                
                # ⭐修正: progress_infoから直接URLを取得して固定⭐
                fixed_url = progress_info.get('url', url)
                open_url_handler = create_open_url_handler(fixed_url)
                
                title_label.bind("<Button-1>", open_url_handler)
                title_label.bind("<Enter>", lambda e: title_label.config(fg="blue"))
                title_label.bind("<Leave>", lambda e: title_label.config(fg="black"))
                # self.log(f"[DEBUG] サブウィンドウタイトルリンク設定: {url}", "debug")  # ⭐DEBUGログを非表示⭐
            # else:
                # self.log(f"[DEBUG] サブウィンドウタイトルリンク設定失敗: url={url}, title={title}", "debug")  # ⭐DEBUGログを非表示⭐
            
            # ⭐修正: ステータス表示（progress_infoの状態を優先、なければURLから取得）⭐
            initial_status = progress_info.get('status', '')
            # ⭐追加: スキップ・完了状態の場合は詳細情報を含める⭐
            current = progress_info.get('current', 0)
            total = progress_info.get('total', 0)
            download_range_info = progress_info.get('download_range_info', {})
            
            # 経過時間を計算
            elapsed_time_str = ""
            start_time = progress_info.get('start_time')
            elapsed_time = progress_info.get('elapsed_time', 0)
            if elapsed_time > 0:
                elapsed_minutes = int(elapsed_time // 60)
                elapsed_seconds = int(elapsed_time % 60)
                elapsed_time_str = f"{elapsed_minutes:02d}:{elapsed_seconds:02d}"
            elif start_time:
                elapsed_seconds = int(time.time() - start_time)
                elapsed_minutes = elapsed_seconds // 60
                elapsed_seconds = elapsed_seconds % 60
                elapsed_time_str = f"{elapsed_minutes:02d}:{elapsed_seconds:02d}"
            
            # ダウンロード範囲情報を取得
            range_text = ""
            if download_range_info and download_range_info.get('enabled'):
                start_range = download_range_info.get('start', 0)
                end_range = download_range_info.get('end')
                if end_range:
                    range_text = f" (範囲: {start_range}-{end_range})"
                else:
                    range_text = f" (範囲: {start_range}-)"
            
            # 状態に応じたステータステキストを生成
            if initial_status == "スキップ" or initial_status == "状態: スキップ":
                if current > 0 and total > 0:
                    if elapsed_time_str:
                        initial_status = f"ページ {current}/{total}{range_text} | 経過: {elapsed_time_str} | 状態: スキップ"
                    else:
                        initial_status = f"ページ {current}/{total}{range_text} | 状態: スキップ"
                else:
                    initial_status = "状態: スキップ"
            elif initial_status == "完了" or initial_status == "状態: 完了":
                if current > 0 and total > 0:
                    if elapsed_time_str:
                        initial_status = f"ページ {current}/{total}{range_text} | 経過: {elapsed_time_str} | 状態: 完了"
                    else:
                        initial_status = f"ページ {current}/{total}{range_text} | 状態: 完了"
                else:
                    initial_status = "状態: 完了"
            elif "中断" in initial_status or "状態: 中断" in initial_status:
                # 中断状態の場合、ページ数情報が含まれていない場合は補完
                if current > 0 and total > 0 and "ページ" not in initial_status:
                    if elapsed_time_str:
                        initial_status = f"ページ {current}/{total}{range_text} | 経過: {elapsed_time_str} | {initial_status}"
                    else:
                        initial_status = f"ページ {current}/{total}{range_text} | {initial_status}"
            elif "エラー" in initial_status or "状態: エラー" in initial_status:
                # エラー状態の場合、ページ数情報が含まれていない場合は補完
                if current > 0 and total > 0 and "ページ" not in initial_status:
                    if elapsed_time_str:
                        initial_status = f"ページ {current}/{total}{range_text} | 経過: {elapsed_time_str} | {initial_status}"
                    else:
                        initial_status = f"ページ {current}/{total}{range_text} | {initial_status}"
            elif "ダウンロード中" in initial_status or "状態: ダウンロード中" in initial_status:
                # ダウンロード中状態の場合、ページ数情報が含まれていない場合は補完
                if current > 0 and total > 0 and "ページ" not in initial_status:
                    if elapsed_time_str:
                        initial_status = f"ページ {current}/{total}{range_text} | 経過: {elapsed_time_str} | {initial_status}"
                    else:
                        initial_status = f"ページ {current}/{total}{range_text} | {initial_status}"
            elif not initial_status or initial_status == "状態: 待機中" or (current > 0 and total > 0 and "ページ" not in initial_status):
                # 状態が空または「状態: 待機中」の場合、またはページ数情報が含まれていない場合は、URLから状態を取得
                progress_url = progress_info.get('url', '')
                if progress_url:
                    download_status = self._get_download_status(progress_url)
                    if current > 0 and total > 0:
                        if elapsed_time_str:
                            initial_status = f"ページ {current}/{total}{range_text} | 経過: {elapsed_time_str} | 状態: {download_status}"
                        else:
                            initial_status = f"ページ {current}/{total}{range_text} | 状態: {download_status}"
                    else:
                        initial_status = f"状態: {download_status}"
                else:
                    initial_status = "状態: 待機中"
            
            # ページ数情報が含まれていない場合、既存のcurrent/totalから補完
            if current > 0 and total > 0 and "ページ" not in initial_status:
                if initial_status:
                    if elapsed_time_str:
                        initial_status = f"ページ {current}/{total}{range_text} | 経過: {elapsed_time_str} | {initial_status}"
                    else:
                        initial_status = f"ページ {current}/{total}{range_text} | {initial_status}"
                else:
                    initial_status = f"ページ {current}/{total}{range_text} | 状態: 待機中"
            
            status_label = ttk.Label(progress_frame, text=initial_status)
            status_label.pack(anchor="w", padx=5, pady=2)
            
            # プログレスバー（ウィンドウ幅いっぱい）
            progress_bar = ttk.Progressbar(progress_frame, mode='determinate')
            progress_bar.pack(fill="x", expand=True, padx=5, pady=(2, 5))
            
            # プログレスバーの値を設定
            if progress_info.get('total', 0) > 0:
                progress_value = (progress_info.get('current', 0) / progress_info.get('total', 1)) * 100
                # プログレスバーの値を0-100の範囲に制限
                progress_value = max(0, min(100, progress_value))
                progress_bar['value'] = progress_value
            else:
                progress_bar['value'] = 0  # 初期値を0に設定
            
            # サブウィンドウ用プログレスバー情報を作成
            separate_progress_info = {
                'frame': progress_frame,
                'bar': progress_bar,
                'status': status_label,
                'title': title_label,
                'open_folder_btn': open_folder_btn,
                'container': self.separate_window_scrollable_frame,
                # ⭐修正: 'state'キーを削除、平坦な構造で保存⭐
                'current': progress_info.get('current', 0),
                'total': progress_info.get('total', 0),
                'title': progress_info.get('title', ''),
                'status': progress_info.get('status', ''),
                'url': progress_info.get('url', ''),  # URL情報を保存（プログレスバー固有）
                'url_index': progress_info.get('url_index'),  # ⭐追加: url_indexを保存⭐
                # ⭐削除: save_folderを保存しない（managed_foldersから動的に取得）⭐
                'original_total': progress_info.get('original_total', 0),  # 元の総ページ数を保存
                'download_range_info': progress_info.get('download_range_info')  # ⭐追加: ダウンロード範囲情報を保存⭐
            }
            
            self.separate_window_progress_bars.append(separate_progress_info)
            
            # ⭐重要: 遅延を設けて情報を確実に更新⭐
            def delayed_update():
                try:
                    # ⭐修正: 最新のプログレスバーのみを更新する条件を削除⭐
                    # 各プログレスバーは独立したURLを持つべきで、上書きしてはいけない
                    
                    # URL情報を再取得（最新のプログレスバーのみ、かつURLが空の場合のみ）
                    if (separate_progress_info == self.separate_window_progress_bars[-1] and 
                        not separate_progress_info.get('url')):
                        if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'current_gallery_url'):
                            current_url = self.parent.downloader_core.current_gallery_url
                            if current_url:
                                separate_progress_info['url'] = current_url
                                # タイトルリンクを更新（URLが空の場合のみ）
                                self._update_title_link(separate_progress_info, current_url)
                        
                    # ⭐修正: フォルダ情報を再取得（最新のプログレスバーのみ、managed_foldersから動的に取得）⭐
                    if separate_progress_info == self.separate_window_progress_bars[-1]:
                        # ⭐修正: progress_infoのURLを使ってmanaged_foldersから動的に取得⭐
                        def get_folder_from_managed_folders(progress_info):
                            """progress_infoのURLを使ってmanaged_foldersからフォルダを取得して開く"""
                            url = progress_info.get('url', '')
                            if url:
                                if hasattr(self.parent, 'normalize_url'):
                                    normalized_url = self.parent.normalize_url(url)
                                elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'normalize_url'):
                                    normalized_url = self.parent.downloader_core.normalize_url(url)
                                else:
                                    normalized_url = url
                                
                                if normalized_url and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'managed_folders') and normalized_url in self.parent.downloader_core.managed_folders:
                                    folder = self.parent.downloader_core.managed_folders[normalized_url]
                                    if folder and os.path.exists(folder):
                                        self._open_specific_folder(folder)
                                    else:
                                        self.log("フォルダが見つかりません", "error")
                                else:
                                    self.log("フォルダ情報が見つかりません", "error")
                            else:
                                self.log("URL情報が見つかりません", "error")
                        
                        # フォルダボタンを有効化
                        if separate_progress_info.get('open_folder_btn'):
                            # managed_foldersから動的に取得
                            progress_url = separate_progress_info.get('url', '')
                            if progress_url:
                                if hasattr(self.parent, 'normalize_url'):
                                    normalized_url = self.parent.normalize_url(progress_url)
                                elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'normalize_url'):
                                    normalized_url = self.parent.downloader_core.normalize_url(progress_url)
                                else:
                                    normalized_url = progress_url
                                
                                if normalized_url and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'managed_folders') and normalized_url in self.parent.downloader_core.managed_folders:
                                    current_folder = self.parent.downloader_core.managed_folders[normalized_url]
                                    if current_folder and os.path.exists(current_folder):
                                        separate_progress_info['open_folder_btn'].config(
                                            state="normal", 
                                            command=lambda pi=separate_progress_info: get_folder_from_managed_folders(pi)
                                        )
                except Exception as e:
                    pass
            
            # 100ms後に遅延更新を実行
            self.parent.root.after(100, delayed_update)
            
            # スクロール領域を更新
            self.separate_window_canvas.configure(scrollregion=self.separate_window_canvas.bbox("all"))
            
            # ⭐修正: プログレスバー生成完了後にオートスクロールを実行⭐
            def scroll_after_creation():
                if self.auto_scroll_enabled and self.separate_window_canvas:
                    try:
                        # プログレスバーが完全に生成されるまで待機
                        self.separate_window_canvas.update_idletasks()
                        # 最下部にスクロール
                        self.separate_window_canvas.yview_moveto(1.0)
                    except Exception as e:
                        self.log(f"オートスクロールエラー: {e}", "error")
            
            # プログレスバー生成完了後にスクロールを実行（遅延時間を増加）
            self.separate_window.after(100, scroll_after_creation)
            
        except Exception as e:
            self.log(f"サブウィンドウプログレスバー作成エラー: {e}", "error")

    def _create_progress_bar_in_separate_window(self, title="", url=""):
        """別ウィンドウ内でプログレスバーを作成（非同期実行）"""
        try:
            # 新しいプログレスバーを作成（再利用しない）
            # 各プログレスバーは独立したURLに対応する必要がある
            
            # 保存フォルダの情報を取得（現在の保存フォルダから）
            save_folder = ""
            # 優先順位: managed_folders > downloader_core.current_save_folder > main_window.current_save_folder > folder_var
            # ⭐修正: managed_foldersからも取得を試みる⭐
            if url:
                # URLが指定されている場合は、そのURLに対応するフォルダを取得
                if hasattr(self.parent, 'normalize_url'):
                    normalized_url = self.parent.normalize_url(url)
                elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'normalize_url'):
                    normalized_url = self.parent.downloader_core.normalize_url(url)
                else:
                    normalized_url = url
                
                if normalized_url and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'managed_folders') and normalized_url in self.parent.downloader_core.managed_folders:
                    save_folder = self.parent.downloader_core.managed_folders[normalized_url]
            
            # URLが指定されていない、またはmanaged_foldersにない場合は、現在のダウンロードフォルダを取得
            if not save_folder:
                if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'current_gallery_url'):
                    if self.parent.downloader_core.current_gallery_url:
                        if hasattr(self.parent, 'normalize_url'):
                            normalized_url = self.parent.normalize_url(self.parent.downloader_core.current_gallery_url)
                        elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'normalize_url'):
                            normalized_url = self.parent.downloader_core.normalize_url(self.parent.downloader_core.current_gallery_url)
                        else:
                            normalized_url = self.parent.downloader_core.current_gallery_url
                        
                        if normalized_url and hasattr(self.parent.downloader_core, 'managed_folders') and normalized_url in self.parent.downloader_core.managed_folders:
                            save_folder = self.parent.downloader_core.managed_folders[normalized_url]
            
            # 次にcurrent_save_folderから取得
            if not save_folder and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'current_save_folder') and self.parent.downloader_core.current_save_folder:
                save_folder = self.parent.downloader_core.current_save_folder
            elif not save_folder and hasattr(self.parent, 'current_save_folder') and self.parent.current_save_folder:
                save_folder = self.parent.current_save_folder
            elif not save_folder and hasattr(self.parent, 'current_download_folder') and self.parent.current_download_folder:
                save_folder = self.parent.current_download_folder
            elif not save_folder and hasattr(self.parent, 'folder_var') and self.parent.folder_var.get():
                save_folder = self.parent.folder_var.get()
            
            # プログレスバーフレームを作成（メインエリアに追加、タイトルは固定）
            progress_frame = ttk.LabelFrame(self.separate_window_scrollable_frame, text="ダウンロード進捗")
            
            # 既存のプログレスバーの下に新しいプログレスバーを追加
            if self.separate_window_progress_bars:
                # 既存のプログレスバーがある場合は、最後のフレームの後に追加
                last_frame = self.separate_window_progress_bars[-1]['frame']
                # 最後のフレームの後に新しいフレームを挿入
                progress_frame.pack(fill="x", expand=True, padx=5, pady=2, after=last_frame)
            else:
                # 最初のプログレスバーの場合は通常通り追加
                progress_frame.pack(fill="x", expand=True, padx=5, pady=2)
            
            # デバッグログを追加
            # ⭐削除: 不必要なDEBUGログを削除⭐
            
            # ⭐修正: このプログレスバーに対応するURLを取得⭐
            # 引数で渡されたURLを使用、なければメインウィンドウのプログレスバーから検索
            corresponding_url = url
            if not corresponding_url:
                for url_idx, main_progress in self._get_progress_bars().items():
                    if main_progress.get('state', {}).get('title') == title:
                        corresponding_url = main_progress.get('url')
                        break
            
            # プログレスバー情報を先に保存（デバッグ用）
            progress_info = {
                'frame': progress_frame,
                'bar': None,  # 後で設定
                'status': None,  # 後で設定
                'title': None,  # 後で設定
                'open_folder_btn': None,  # 後で設定
                'url': corresponding_url,  # ⭐修正: 対応するURLを保存⭐
                'container': self.separate_window_scrollable_frame,
                'state': {
                    'current': 0,
                    'total': 0,
                    'title': title,
                    'status': "状態: 待機中"
                }
            }
            self.separate_window_progress_bars.append(progress_info)
            
            # ヘッダーフレーム（タイトルと保存フォルダを開くボタン）
            header_frame = ttk.Frame(progress_frame)
            header_frame.pack(fill="x", padx=5, pady=2)
            
            # タイトル表示（ハイパーリンク化）
            title_label = tk.Label(header_frame, text=title, 
                                 fg="black", cursor="hand2", font=("Arial", 9))
            title_label.pack(side="left", anchor="w")
            
            # ⭐修正: クリックイベントをバインド（対応するURLを使用）⭐
            if corresponding_url:
                title_label.bind("<Button-1>", lambda e, url=corresponding_url: self._open_gallery_url(url))
                title_label.bind("<Enter>", lambda e: title_label.config(fg="blue"))
                title_label.bind("<Leave>", lambda e: title_label.config(fg="black"))
            
            # 保存フォルダを開くボタン（右上）
            # ⭐修正: managed_foldersから動的に取得⭐
            def get_folder_from_managed_folders_for_separate(progress_info):
                """progress_infoのURLを使ってmanaged_foldersからフォルダを取得して開く"""
                # ⭐修正: progress_infoからURLを取得（複数の方法を試行）⭐
                url = progress_info.get('url', '')
                if not url:
                    # progress_infoにurlがない場合は、url_indexから取得を試みる
                    url_index = progress_info.get('url_index')
                    if url_index is not None and hasattr(self.parent, 'downloader_core'):
                        # StateManagerからURLを取得
                        if hasattr(self.parent.downloader_core, 'state_manager'):
                            progress_bars = self.parent.downloader_core.state_manager.download_state.progress_bars
                            if url_index in progress_bars:
                                url = progress_bars[url_index].get('url', '')
                
                if url:
                    # ⭐修正: normalize_urlの処理を統一⭐
                    if hasattr(self.parent, 'normalize_url'):
                        normalized_url = self.parent.normalize_url(url)
                    elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'normalize_url'):
                        normalized_url = self.parent.downloader_core.normalize_url(url)
                    else:
                        normalized_url = url
                    
                    # ⭐修正: managed_foldersから取得（複数の方法を試行）⭐
                    folder = None
                    if normalized_url and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'managed_folders'):
                        folder = self.parent.downloader_core.managed_folders.get(normalized_url)
                    
                    # ⭐修正: フォルダが見つからない場合は、progress_infoから直接取得を試行⭐
                    if not folder:
                        folder = progress_info.get('save_folder', '')
                    
                    # ⭐修正: フォルダが見つからない場合は、StateManagerのprogress_barsから取得を試行⭐
                    if not folder:
                        url_index = progress_info.get('url_index')
                        if url_index is not None and hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                            progress_bars = self.parent.downloader_core.state_manager.download_state.progress_bars
                            if url_index in progress_bars:
                                folder = progress_bars[url_index].get('save_folder', '')
                    
                    if folder and os.path.exists(folder):
                        self._open_specific_folder(folder)
                    else:
                        self.log(f"フォルダが見つかりません: {folder}", "error")
                else:
                    self.log("URL情報が見つかりません", "error")
            
            open_folder_btn = ttk.Button(header_frame, text="保存フォルダを開く", 
                                       command=lambda pi=progress_info: get_folder_from_managed_folders_for_separate(pi), width=15)
            open_folder_btn.pack(side="right", anchor="e", padx=(5, 0))
            
            # ステータス表示
            status_label = ttk.Label(progress_frame, text="状態: 待機中")
            status_label.pack(anchor="w", padx=5, pady=2)
            
            # プログレスバー（ウィンドウ幅いっぱい）
            progress_bar = ttk.Progressbar(progress_frame, mode='determinate')
            progress_bar.pack(fill="x", expand=True, padx=5, pady=(2, 5))
            
            # プログレスバー情報を更新
            progress_info['bar'] = progress_bar
            progress_info['status'] = status_label
            progress_info['title'] = title_label
            progress_info['open_folder_btn'] = open_folder_btn
            
            # スクロール領域を更新
            self.separate_window_canvas.configure(scrollregion=self.separate_window_canvas.bbox("all"))
            
            # タイトル更新処理を即座に実行
            # ⭐修正: progress_infoからurl_indexを取得して渡す⭐
            url_index = progress_info.get('url_index')
            if url_index is not None:
                self._update_separate_window_title(title, url_index=url_index)
            
        except Exception as e:
            self.log(f"別ウィンドウプログレスバー作成エラー: {e}", "error")

    def _update_separate_window_progress_immediate(self, current, total, status_text, url=None, url_index=None):
        """別ウィンドウのプログレスバーを即座に更新"""
        try:
            if not self.separate_window_progress_bars:
                return
            
            # ⭐修正: url_indexのみで検索（URL検索は削除）⭐
            target_progress = None
            if url_index is not None and url_index >= 0:
                for progress in self.separate_window_progress_bars:
                    if progress.get('url_index') == url_index:
                        target_progress = progress
                        break
            
            if not target_progress:
                return  # url_indexが見つからない場合は何もしない
            
            # プログレスバーの値を更新
            if target_progress.get('bar') and target_progress['bar'].winfo_exists():
                if total > 0:
                    progress_value = (current / total) * 100
                    progress_value = max(0, min(100, progress_value))
                    target_progress['bar']['value'] = progress_value
                else:
                    target_progress['bar']['value'] = 0
            
            # ステータスラベルを即座に更新
            if (target_progress.get('status') and 
                hasattr(target_progress['status'], 'winfo_exists') and 
                target_progress['status'].winfo_exists()):
                try:
                    # ⭐修正: status_textが空の場合は適切な状態を生成⭐
                    if not status_text:
                        # ⭐修正: URLを指定してダウンロード状態を取得⭐
                        progress_url = target_progress.get('url', url)
                        download_status = self._get_download_status(progress_url)
                        if current == 0 and total == 0:
                            status_text = f"状態: {download_status}"
                        elif current < total:
                            status_text = f"ページ {current}/{total} | 状態: {download_status}"
                        elif current >= total:
                            status_text = f"ページ {current}/{total} | 状態: 完了"
                    
                    # status_textが空でない場合のみ更新
                    if status_text:
                        target_progress['status'].config(text=status_text)
                        if target_progress.get('state'):
                            target_progress['state']['status'] = status_text
                except (tk.TclError, AttributeError) as e:
                    # 不必要なDEBUGログを削除
                    pass
                    
        except Exception as e:
            self.log(f"別ウィンドウプログレス即座更新エラー: {e}", "error")

    def _update_separate_window_progress(self, current, total, status="", url=None, url_index=None, download_range_info=None):
        """別ウィンドウのプログレスバーを更新"""
        try:
            if not self.separate_window_progress_bars:
                return
            
            # ★ url_index のみで検索
            target_progress = None
            if url_index is not None and url_index >= 0:
                for progress in self.separate_window_progress_bars:
                    if progress.get('url_index') == url_index:
                        target_progress = progress
                        break
            
            if not target_progress:
                return  # 該当なし
            
            # ★ 完了済みなら更新しない
            if self._is_progress_completed(target_progress):
                return
            
            latest_progress = target_progress
            
            # ============================================
            # ★ total の扱い（停止→再開時の total 変動対策）
            # ============================================
            existing_total = latest_progress.get('state', {}).get('total', 0)
            if total > 1:
                display_total = total
                latest_progress['state']['total'] = total
            elif existing_total > 0:
                display_total = existing_total
            else:
                display_total = total
                latest_progress['state']['total'] = total
            
            # ============================================
            # ★ プログレスバーの更新
            # ============================================
            if latest_progress['bar'] and latest_progress['bar'].winfo_exists():
                if display_total > 0:
                    progress_value = (current / display_total) * 100
                    progress_value = max(0, min(100, progress_value))
                    latest_progress['bar']['value'] = progress_value
                else:
                    latest_progress['bar']['value'] = 0
                
            # ============================================
            # ★ ステータス更新
            # ============================================
            if (latest_progress.get('status') and 
                hasattr(latest_progress['status'], 'winfo_exists') and 
                latest_progress['status'].winfo_exists()):

                try:
                    # 既存のステータスを取得
                    existing_status = latest_progress.get('state', {}).get('status', '')
                    
                    # ① 明示的に status が渡されていればそれを優先
                    if status:
                        status_text = status
                    elif status == "":
                        # ② statusが空文字列の場合は、既存の状態情報を保持しつつ進捗情報のみを更新
                        # 状態取得
                        progress_url = latest_progress.get('url', url)
                        download_status = self._get_download_status(progress_url)
                        
                        # 経過時間計算
                        start_time = latest_progress.get('start_time')
                        elapsed_time = 0
                        current_time = time.time()

                        if start_time:
                            elapsed_time = current_time - start_time
                        elif getattr(self, 'current_download_start_time', None):
                            elapsed_time = current_time - self.current_download_start_time
                            elapsed_time -= getattr(self, 'total_paused_time', 0)
                            if getattr(self, 'download_pause_start_time', None):
                                elapsed_time -= (current_time - self.download_pause_start_time)

                        # 進捗情報を生成
                        is_completed = (current >= total and total > 0)
                        if current > 0 and total > 0 and elapsed_time > 0:
                            estimated_total_time = elapsed_time * (total / current)
                            remaining_time = max(0, estimated_total_time - elapsed_time)
                            elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                            remaining_str = f"{int(remaining_time//60):02d}:{int(remaining_time%60):02d}"
                            
                            if is_completed:
                                progress_info = f"ページ {current}/{total} | 経過: {elapsed_str}"
                            else:
                                progress_info = f"ページ {current}/{total} | 経過: {elapsed_str} | 残り: {remaining_str}"
                        elif current > 0 and total > 0:
                            progress_info = f"ページ {current}/{total}"
                        else:
                            progress_info = f"ページ {current}/{total}" if total > 0 else ""

                        # ダウンロード範囲情報を取得
                        download_range_text = ""
                        if download_range_info and download_range_info.get('enabled'):
                            progress_url = latest_progress.get('url', url)
                            if progress_url:
                                download_range_text = self._get_download_range_text(progress_url)
                        elif not download_range_text:
                            progress_url = latest_progress.get('url', url)
                            if progress_url:
                                download_range_text = self._get_download_range_text(progress_url)
                        
                        # 既存の状態情報から「状態:」を抽出
                        existing_state = ""
                        if existing_status:
                            parts = existing_status.split('|')
                            for part in parts:
                                part = part.strip()
                                if part.startswith('状態:'):
                                    existing_state = part
                                    break
                        
                        # 状態が空の場合は適切な状態を生成
                        if not existing_state:
                            if is_completed:
                                existing_state = "状態: 完了"
                            elif current == 0 and total == 0:
                                existing_state = "状態: 待機中"
                            elif current < total:
                                existing_state = "状態: ダウンロード中"
                            else:
                                existing_state = f"状態: {download_status}"

                        # ステータステキストを構築
                        parts = []
                        if progress_info:
                            parts.append(progress_info)
                        if download_range_text:
                            parts.append(download_range_text)
                        if existing_state:
                            parts.append(existing_state)
                        status_text = " | ".join(parts) if parts else existing_state or "状態: 待機中"
                    else:
                        # ③ statusが指定されていない場合（Noneなど）
                        progress_url = latest_progress.get('url', url)
                        download_status = self._get_download_status(progress_url)

                        # 経過時間計算
                        start_time = latest_progress.get('start_time')
                        elapsed_time = 0
                        current_time = time.time()

                        if start_time:
                            elapsed_time = current_time - start_time
                        elif getattr(self, 'current_download_start_time', None):
                            elapsed_time = current_time - self.current_download_start_time
                            elapsed_time -= getattr(self, 'total_paused_time', 0)
                            if getattr(self, 'download_pause_start_time', None):
                                elapsed_time -= (current_time - self.download_pause_start_time)

                        # 時間表示の構築
                        if current > 0 and total > 0 and elapsed_time > 0:
                            estimated_total_time = elapsed_time * (total / current)
                            remaining_time = max(0, estimated_total_time - elapsed_time)
                            elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                            remaining_str = f"{int(remaining_time//60):02d}:{int(remaining_time%60):02d}"
                            
                            status_text = (
                                f"ページ {current}/{total} | 経過: {elapsed_str} | "
                                f"残り: {remaining_str} | 状態: {download_status}"
                            )
                        else:
                            # 状態自動生成
                            if current == 0 and total == 0:
                                status_text = "状態: 待機中"
                            elif current < total:
                                status_text = f"ページ {current}/{total} | 状態: ダウンロード中"
                            else:
                                status_text = f"ページ {current}/{total} | 状態: 完了"
                        
                    # ★ ステータス更新
                    latest_progress['status'].config(text=status_text)
                    if latest_progress.get('state'):
                        latest_progress['state']['status'] = status_text

                    # ============================================
                    # ★ タイトル更新（state の title のみ使用）
                    # ============================================
                    if latest_progress.get('title') and latest_progress['title'].winfo_exists():
                        saved_title = latest_progress['state'].get('title', '')
                        if saved_title and saved_title != "準備中...":
                            latest_progress['title'].config(text=saved_title)

                except (tk.TclError, AttributeError):
                    pass
                    
            # ============================================
            # ★ 保存フォルダボタン更新
            # ============================================
            if latest_progress.get('open_folder_btn'):
                try:
                    progress_url = latest_progress.get('url', '')
                    save_folder = ''

                    # managed_folders → current_save_folder → parent fallback
                    if progress_url:
                        normalized_url = (
                            self.parent.normalize_url(progress_url)
                            if hasattr(self.parent, 'normalize_url')
                            else progress_url
                        )
                        if normalized_url in getattr(self.parent.downloader_core, 'managed_folders', {}):
                            save_folder = self.parent.downloader_core.managed_folders[normalized_url]

                    if (not save_folder 
                        and getattr(self.parent.downloader_core, 'current_gallery_url', None)):

                        ng = (
                            self.parent.normalize_url(self.parent.downloader_core.current_gallery_url)
                            if hasattr(self.parent, 'normalize_url')
                            else self.parent.downloader_core.current_gallery_url
                        )
                        if normalized_url == ng:
                            save_folder = getattr(self.parent.downloader_core, 'current_save_folder', '')

                    if not save_folder:
                        save_folder = getattr(self.parent, 'current_save_folder', '')
                        
                    # 有効化条件
                    if save_folder and os.path.exists(save_folder):
                        if str(latest_progress['open_folder_btn']['state']) == 'disabled':

                            def open_folder(pi=latest_progress):
                                purl = pi.get('url', '')
                                if not purl:
                                    self.log("URL情報が見つかりません", "error")
                                    return

                                nurl = (
                                    self.parent.normalize_url(purl)
                                    if hasattr(self.parent, 'normalize_url')
                                    else purl
                                )

                                mfolders = getattr(self.parent.downloader_core, 'managed_folders', {})
                                folder = mfolders.get(nurl)
                                if folder and os.path.exists(folder):
                                    self._open_specific_folder(folder)
                                else:
                                    self.log("フォルダが見つかりません", "error")

                                    latest_progress['open_folder_btn'].config(
                                        state="normal", 
                                command=open_folder
                            )

                except Exception:
                    pass
            
            # ============================================
            # ★ タイトルリンク更新（URL一致時のみ）
            # ============================================
            progress_url = latest_progress.get('url', '')
            if url and progress_url:
                normalize = (
                    self.parent.normalize_url if hasattr(self.parent, 'normalize_url')
                    else (lambda x: x)
                )
                if normalize(url) == normalize(progress_url):
                    self._update_title_link(latest_progress, progress_url)
                
            # ============================================
            # ★ state を更新
            # ============================================
                if latest_progress.get('state'):
                    latest_progress['state']['current'] = current
                    latest_progress['state']['total'] = total
                    latest_progress['state']['status'] = status
                
        except Exception as e:
            self.log(f"別ウィンドウプログレスバー更新エラー: {e}", "error")

    def _update_title_link(self, progress_info, url):
        """タイトルリンクを更新（安定性改善版）"""
        try:
            # 別ウィンドウのプログレスバーでタイトルリンクを更新
            for separate_progress in self.separate_window_progress_bars:
                # ⭐修正: より確実なマッチング条件⭐
                if (separate_progress.get('title') and 
                    hasattr(separate_progress['title'], 'winfo_exists') and 
                    separate_progress['title'].winfo_exists()):
                    
                    # 既存のイベントをクリア
                    try:
                        separate_progress['title'].unbind("<Button-1>")
                        separate_progress['title'].unbind("<Enter>")
                        separate_progress['title'].unbind("<Leave>")
                    except (tk.TclError, AttributeError):
                        pass
                    
                    # ⭐修正: クロージャでURLを固定（最新のURLで上書きされないように）⭐
                    # separate_progressから直接URLを取得して固定
                    fixed_url = separate_progress.get('url', url)
                    def create_open_url_handler(fixed_url):
                        def open_url_handler(event):
                            self._open_gallery_url(fixed_url)
                        return open_url_handler
                    
                    open_url_handler = create_open_url_handler(fixed_url)
                    
                    try:
                        separate_progress['title'].bind("<Button-1>", open_url_handler)
                        separate_progress['title'].bind("<Enter>", lambda e: separate_progress['title'].config(fg="gray"))
                        separate_progress['title'].bind("<Leave>", lambda e: separate_progress['title'].config(fg="black"))
                        
                        # URL情報を保存（既に保存されている場合は上書きしない）
                        if 'url' not in separate_progress or not separate_progress['url']:
                            separate_progress['url'] = fixed_url
                    except (tk.TclError, AttributeError):
                        pass
            
            # メインウィンドウのプログレスバーでもタイトルリンクを更新
            if progress_info.get('title') and hasattr(progress_info['title'], 'winfo_exists') and progress_info['title'].winfo_exists():
                # 既存のイベントをクリア
                try:
                    progress_info['title'].unbind("<Button-1>")
                    progress_info['title'].unbind("<Enter>")
                    progress_info['title'].unbind("<Leave>")
                except (tk.TclError, AttributeError):
                    pass
                
                # ⭐修正: クロージャでURLを固定（最新のURLで上書きされないように）⭐
                # progress_infoから直接URLを取得して固定
                fixed_url = progress_info.get('url', url)
                def create_open_url_handler(fixed_url):
                    def open_url_handler(event):
                        self._open_gallery_url(fixed_url)
                    return open_url_handler
                
                open_url_handler = create_open_url_handler(fixed_url)
                
                try:
                    progress_info['title'].bind("<Button-1>", open_url_handler)
                    progress_info['title'].bind("<Enter>", lambda e: progress_info['title'].config(fg="gray"))
                    progress_info['title'].bind("<Leave>", lambda e: progress_info['title'].config(fg="black"))
                    
                    # URL情報を保存
                    progress_info['url'] = url
                    # 新しいURLの場合のみログ出力
                    if not hasattr(self, '_last_title_url') or self._last_title_url != url:
                        # self.log(f"[DEBUG] メインウィンドウタイトルリンク更新: {url}", "debug")
                        self._last_title_url = url
                except (tk.TclError, AttributeError):
                    pass
                    
        except Exception as e:
            # タイトルリンク更新エラーは無視
            pass

    def hide_current_progress_bar(self):
        """プログレスバー非表示（ペインから削除）"""
        if hasattr(self, 'progress_container') and hasattr(self, 'main_v_pane'):
            try:
                # メインウィンドウのプログレスバーをクリーンアップ
                if self.progress_container and self.progress_container.winfo_exists():
                    if self.progress_container in self.main_v_pane.panes():
                        self.main_v_pane.forget(self.progress_container)
                    self.progress_container.destroy()
                
                # 現在のプログレスバーの参照をクリア
                self.progress_container = None
                self.current_progress_bar = None
                self.current_progress_title = None
                self.current_progress_status = None
                self.current_progress_frame = None
                self.progress_visible = False
                self.progress_cleanup_needed = False
                
            except Exception as e:
                self.log(f"プログレスバー非表示エラー: {e}", "error")

    def preserve_skipped_progress_bar(self, url):
        """スキップされたプログレスバーの情報を保持（シンプルな設計）"""
        try:
            # 既存のプログレスバーを探す（StateManager経由）
            for url_idx, progress in self._get_progress_bars().items():
                if progress.get('url') == url:
                    # スキップ状態に更新（ページ数・％・経過時間は保持）
                    progress['state']['status'] = "スキップ"
                    if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                        self.parent.downloader_core.state_manager.set_progress_bar(url_idx, progress)
                    # スキップされたプログレスバーを履歴から削除しない
                    progress['state']['preserved'] = True
                    
                    # プログレスバーの情報を保持（ページ数・％・経過時間を保持）
                    # ⭐防御的コーディング: Noneチェックを追加⭐
                    current = progress['state'].get('current')
                    total = progress['state'].get('total')
                    current = current if current is not None else 0
                    total = total if total is not None else 0
                    percentage = (current / total * 100) if total > 0 else 0
                    
                    # 経過時間を計算・保持
                    elapsed_time = ""
                    # ⭐修正: 各プログレスバーごとの開始時間を使用⭐
                    start_time = progress.get('start_time')
                    if start_time:
                        elapsed_seconds = int(time.time() - start_time)
                        elapsed_time = f"経過時間: {elapsed_seconds}秒"
                    elif hasattr(self, 'current_download_start_time') and self.current_download_start_time:
                        # フォールバック: インスタンス変数を使用
                        elapsed_seconds = int(time.time() - self.current_download_start_time)
                        elapsed_time = f"経過時間: {elapsed_seconds}秒"
                    
                    # ⭐削除: 不必要なDEBUGログを削除⭐
                    
                    # メインウィンドウのプログレスバー表示を更新（情報保持）
                    if hasattr(self, 'current_progress_status') and self.current_progress_status:
                        status_text = f"状態: スキップ ({int(current)}/{int(total)} - {percentage:.1f}%)"
                        if elapsed_time:
                            status_text += f" - {elapsed_time}"
                        self.current_progress_status.config(text=status_text)
                    
                    # 別ウィンドウのプログレスバーも更新
                    if hasattr(self, 'separate_window_progress_bars'):
                        for separate_progress in self.separate_window_progress_bars:
                            if separate_progress.get('url') == url:
                                separate_progress['state']['status'] = "スキップ"
                                # 別ウィンドウの表示も更新（情報保持）
                                if separate_progress.get('status_label'):
                                    # ⭐修正: 詳細情報を含むステータステキストを生成⭐
                                    # 経過時間を計算
                                    elapsed_time_str = ""
                                    start_time = separate_progress.get('start_time')
                                    elapsed_time_sec = separate_progress.get('elapsed_time', 0)
                                    if elapsed_time_sec > 0:
                                        elapsed_minutes = int(elapsed_time_sec // 60)
                                        elapsed_seconds = int(elapsed_time_sec % 60)
                                        elapsed_time_str = f"{elapsed_minutes:02d}:{elapsed_seconds:02d}"
                                    elif start_time:
                                        elapsed_seconds = int(time.time() - start_time)
                                        elapsed_minutes = elapsed_seconds // 60
                                        elapsed_seconds = elapsed_seconds % 60
                                        elapsed_time_str = f"{elapsed_minutes:02d}:{elapsed_seconds:02d}"
                                    
                                    # ダウンロード範囲情報を取得
                                    range_text = ""
                                    download_range_info = separate_progress.get('download_range_info', {})
                                    if download_range_info and download_range_info.get('enabled'):
                                        start_range = download_range_info.get('start', 0)
                                        end_range = download_range_info.get('end')
                                        if end_range:
                                            range_text = f" (範囲: {start_range}-{end_range})"
                                        else:
                                            range_text = f" (範囲: {start_range}-)"
                                    
                                    if current > 0 and total > 0:
                                        if elapsed_time_str:
                                            status_text = f"ページ {current}/{total}{range_text} | 経過: {elapsed_time_str} | 状態: スキップ"
                                        else:
                                            status_text = f"ページ {current}/{total}{range_text} | 状態: スキップ"
                                    else:
                                        status_text = "状態: スキップ"
                                    separate_progress['status_label'].config(text=status_text)
                                break
                    
                    return True
            
            # ⭐削除: 不必要なDEBUGログを削除⭐
            return False
            
        except Exception as e:
            self.log(f"プログレスバー保持エラー: {e}", "error")
            return False

    def clear_all_progress_bars(self):
        """全てのプログレスバーをクリア"""
        try:
            # メインウィンドウのプログレスバーをクリア
            self.hide_current_progress_bar()
            
            # サブウィンドウのプログレスバーをクリア（GUI要素のみ）
            if hasattr(self, 'separate_window_progress_bars'):
                for progress_info in self.separate_window_progress_bars:
                    try:
                        if progress_info.get('frame') and progress_info['frame'].winfo_exists():
                            progress_info['frame'].destroy()
                    except Exception:
                        pass
                self.separate_window_progress_bars.clear()
            
            # StateManagerのプログレスバー状態をクリア
            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                state_manager = self.parent.downloader_core.state_manager
                # 全てのプログレスバーをクリア
                # ⭐修正: StateManagerはlock属性を持たないため、_state_lockを使用⭐
                with state_manager._state_lock:
                    state_manager.download_state.progress_bars.clear()
                self.log("StateManagerのプログレスバー状態をクリアしました", "info")
            
            # ⭐追加: 最新のアクティブなインデックスもリセット⭐
            self.latest_active_index = -1
            
            # サブウィンドウを閉じる
            if hasattr(self, 'separate_window') and self.separate_window:
                try:
                    if self.separate_window.winfo_exists():
                        self.separate_window.destroy()
                except Exception:
                    pass
                self.separate_window = None
            
        except Exception as e:
            self.log(f"全プログレスバークリアエラー: {e}", "error")

    def switch_progress_display_mode(self):
        """プログレスバー表示モードを切り替え（シームレスに動作）"""
        try:
            # 別ウィンドウ表示オプションをチェック
            if hasattr(self.parent, 'progress_separate_window_enabled') and self.parent.progress_separate_window_enabled.get():
                # サブウィンドウ表示モード
                # ⭐修正: メインウィンドウのプログレスバーは削除しない（保守性向上）⭐
                # サブウィンドウで全てのプログレスバーを表示（プログレスバーがなくてもウィンドウを開く）
                self._show_progress_in_separate_window()
            else:
                # メインウィンドウ表示モード
                # サブウィンドウを閉じる
                if hasattr(self, 'separate_window') and self.separate_window:
                    try:
                        if self.separate_window.winfo_exists():
                            self.separate_window.destroy()
                    except Exception:
                        pass
                    self.separate_window = None
                # サブウィンドウのプログレスバーをクリア
                self.separate_window_progress_bars.clear()
                # ⭐追加: ウィンドウを閉じた時にダウンロードマネージャーボタンの状態を更新⭐
                if hasattr(self.parent, 'options_panel') and hasattr(self.parent.options_panel, '_update_download_manager_button_state'):
                    self.parent.options_panel._update_download_manager_button_state()
                # メインウィンドウのプログレスバーをクリアして再作成
                self.hide_current_progress_bar()
                # メインウィンドウで最新のプログレスバーのみ表示
                progress_bars = self._get_progress_bars()
                if progress_bars:
                    self._show_latest_progress_in_main_window()
                
                # 現在のプログレス情報を復元
                progress_bars = self._get_progress_bars()
                if progress_bars:
                    # 最新のアクティブなプログレスバーを取得
                    if self.latest_active_index is not None and self.latest_active_index >= 0:
                        latest_progress = self._get_progress_bar(self.latest_active_index)
                    else:
                        # 最大のurl_indexを持つプログレスバーを取得
                        latest_url_index = max(progress_bars.keys()) if progress_bars else -1
                        latest_progress = progress_bars.get(latest_url_index) if latest_url_index >= 0 else None
                    
                    if latest_progress:
                        current = latest_progress['state'].get('current', 0)
                        total = latest_progress['state'].get('total', 0)
                        status = latest_progress['state'].get('status', '')
                    else:
                        return
                    
                    # プログレスバーの値を復元
                    if hasattr(self, 'current_progress_bar') and self.current_progress_bar:
                        if total > 0:
                            progress_value = (current / total) * 100
                            # プログレスバーの値を0-100の範囲に制限
                            progress_value = max(0, min(100, progress_value))
                            self.current_progress_bar['value'] = progress_value
                        else:
                            self.current_progress_bar['value'] = 0  # 初期値を0に設定
                    
                    # ステータスを復元
                    if hasattr(self, 'current_progress_status') and self.current_progress_status:
                        self.current_progress_status.config(text=f"状態: {status}")
                    
                    # タイトルを復元
                    title = latest_progress['state'].get('title', '')
                    if title and hasattr(self, 'current_progress_title') and self.current_progress_title:
                        self.current_progress_title.config(text=f"タイトル: {title}")
                
        except Exception as e:
            self.log(f"プログレスバー表示モード切り替えエラー: {e}", "error")

    def update_current_progress(self, current, total, status="", url=None, download_range_info=None, url_index=None):
        """現在のプログレス更新（完全非同期版・ページ進行時に必ず更新）"""
        # ⭐修正: 更新頻度制限を削除し、ページが進むタイミングで必ず更新⭐
        # ⭐修正: 全ての処理を非同期で実行⭐
        def update_progress_async():
            try:
                with self.progress_update_lock:
                    # ⭐変更: プログレスバー保持数制限をチェック⭐
                    self._check_progress_retention_limit()
                    
                    # ⭐変更: url_indexで直接取得⭐
                    target_progress = None
                    current_url_index = None
                    
                    # ⭐修正: StateManagerからプログレスバーを取得⭐
                    # 1. url_indexで直接取得
                    if url_index is not None and url_index >= 0:
                        current_url_index = url_index
                        # ⭐修正: StateManagerから取得を試みる⭐
                        if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                            target_progress = self.parent.downloader_core.state_manager.get_progress_bar(url_index)
                        else:
                            # フォールバック: ローカルのprogress_barsから取得
                            target_progress = self._get_progress_bar(url_index)
                        
                        if target_progress and not self._is_progress_completed(target_progress):
                            self.latest_active_index = url_index
                        elif target_progress:
                            # 完了済みなので更新しない
                            target_progress = None
                    else:
                        # url_indexが無効な場合はエラーログを出力してスキップ
                        self.log(f"[WARNING] update_current_progress: url_indexが無効です: {url_index}", "warning")
                        return
                    
                    # 2. url_indexが見つからない場合は新しいプログレスバーを作成
                    if not target_progress and current_url_index is not None and current_url_index >= 0:
                        if url:
                            # ⭐修正: タイトルは「準備中...」で初期化（HTML解析後にupdate_progress_titleで更新）⭐
                            title_text = "準備中..."
                            if hasattr(self.parent, 'normalize_url'):
                                normalized_url_for_save = self.parent.normalize_url(url)
                            else:
                                normalized_url_for_save = url
                            progress_info = {
                                'url': normalized_url_for_save,
                                'url_index': url_index,  # ⭐重要: url_indexを保存⭐
                                'frame': None,
                                'bar': None,
                                'status': None,
                                'title': None,
                                'container': None,
                                'original_total': total if total > 0 else 0,
                                'start_time': time.time(),  # ⭐追加: 各プログレスバーごとの開始時間を保存⭐
                                'elapsed_time': 0,  # ⭐追加: 経過時間を保存（初期値0）⭐
                                'download_range_info': download_range_info.copy() if download_range_info else None,
                                'state': {
                                    'current': current,
                                    'total': total,
                                    'title': title_text,  # ⭐修正: 「準備中...」で初期化⭐
                                    'status': "状態: 待機中"
                                }
                            }
                            # ⭐修正: StateManagerに保存⭐
                            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                                self.parent.downloader_core.state_manager.set_progress_bar(current_url_index, progress_info)
                            # StateManagerに保存済み（self.progress_barsは削除）
                            target_progress = progress_info
                            self.latest_active_index = current_url_index
                            
                            # メインウィンドウ表示時は最新のプログレスバーを表示（非同期）
                            if not (hasattr(self.parent, 'progress_separate_window_enabled') and self.parent.progress_separate_window_enabled.get()):
                                self.parent.root.after(0, self._show_latest_progress_in_main_window)
                        else:
                            return  # url_indexはあるがurlがない場合はスキップ
                    
                    # ⭐削除: 3. url_indexがない場合はURLで検索（フォールバック）⭐
                    # ⭐削除: 4. URL検索でも見つからない場合は新しいプログレスバーを作成⭐
                    # url_indexがない場合は、新しいプログレスバーを作成しない（url_indexが必須）
                    # 既存のプログレスバーを更新してはいけない
                    
                    # 3. どちらもない場合はスキップ
                    if not target_progress:
                        return
                
                    # 6. 完了したプログレスバーは更新しない
                    if self._is_progress_completed(target_progress):
                        return
                    
                    latest_progress = target_progress
                    old_total = latest_progress['state'].get('total', 0)
                    existing_total = old_total
                    
                    # totalが0または1の場合は既存のtotalを保持（再開時の再計算を防ぐ）
                    if total > 1:
                        # totalが1より大きい場合のみ更新
                        latest_progress['state']['total'] = total
                        display_total = total
                
                    # 初回設定時はoriginal_totalを設定
                    if latest_progress['original_total'] == 0:
                        latest_progress['original_total'] = total
                    elif total > latest_progress['original_total']:
                        # 復帰ポイントから再開する場合、totalがoriginal_totalより大きい場合は更新
                        latest_progress['original_total'] = total
                    elif existing_total > 0:
                        # 既存のtotalがある場合は保持（totalは更新しない）
                        # これにより、中断・再開時にページ数が再計算されない
                        display_total = existing_total
                        # totalは更新しない（既存の値を保持）
                    else:
                        # 既存のtotalもない場合は、渡されたtotalを使用
                        display_total = total
                        latest_progress['state']['total'] = total
                        if latest_progress['original_total'] == 0 and total > 0:
                            latest_progress['original_total'] = total
                
                    # StateManagerに状態を更新（イベント駆動型GUI更新をトリガー）
                    latest_progress['state']['current'] = current
                    if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                        # StateManagerに更新（これによりイベントが発火し、GUIが自動更新される）
                        self.parent.downloader_core.state_manager.update_progress_bar_state(
                            current_url_index, 
                            current=current, 
                            total=total if total > 1 else None,  # totalが1より大きい場合のみ更新
                            status=latest_progress['state'].get('status')
                        )
                    # ⭐追加: 即座にGUI更新も実行（イベント駆動と併用）⭐
                    # イベント駆動型更新は非同期で実行されるため、即座に更新する場合は直接呼び出す
                    def update_gui_immediate():
                        try:
                            self._update_main_window_progress_bar(current_url_index, latest_progress)
                            self._update_separate_window_progress_bar(current_url_index, latest_progress)
                        except Exception as e:
                            self.log(f"即座GUI更新エラー: {e}", "error")
                    
                        # メインスレッドで実行
                        if hasattr(self.parent, 'root'):
                            self.parent.root.after(0, update_gui_immediate)
                    
                    # 状態表示を改善（既存の進捗情報を保持しつつ、状態情報とダウンロード範囲情報を追加）
                    existing_status = latest_progress['state'].get('status', '')
                    
                    if status:
                        # statusパラメータが渡された場合
                        if status.startswith('状態:'):
                            # 「状態:」で始まる場合は、既存の進捗情報に追加
                            # 既存の進捗情報からページ数、経過時間、残り予想時間を抽出
                            progress_info = ""
                            if existing_status and 'ページ' in existing_status:
                                # 既存の進捗情報からページ数、経過時間、残り予想時間を抽出
                                # 形式: "ページ X/Y | 経過: MM:SS | 残り予想: MM:SS"
                                parts = existing_status.split('|')
                                progress_parts = []
                                for part in parts:
                                    part = part.strip()
                                    if part.startswith('ページ') or part.startswith('経過:') or part.startswith('残り予想:') or part.startswith('残り:'):
                                        progress_parts.append(part)
                                if progress_parts:
                                    progress_info = ' | '.join(progress_parts)
                            
                            # 進捗情報がない場合は生成
                            if not progress_info:
                                # ⭐修正: 完了状態をチェック⭐
                                is_completed = (current >= total and total > 0)
                                
                                if current > 0 and total > 0:
                                    # ⭐修正: 各プログレスバーごとの開始時間を使用⭐
                                    # ⭐修正: latest_progressから取得（progress_infoは文字列）⭐
                                    start_time = latest_progress.get('start_time')
                                    if start_time:
                                        elapsed_time = time.time() - start_time
                                    elif hasattr(self, 'current_download_start_time') and self.current_download_start_time:
                                        # フォールバック: インスタンス変数を使用
                                        elapsed_time = time.time() - self.current_download_start_time
                                    
                                    if start_time or (hasattr(self, 'current_download_start_time') and self.current_download_start_time):
                                        elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                                        
                                        # ⭐修正: 完了後は残り予想時間を非表示、計算できない場合も非表示⭐
                                        if is_completed:
                                            # 完了後は残り予想時間を非表示
                                            progress_info = f"ページ {current}/{total} | 経過: {elapsed_str}"
                                        elif current > 0 and elapsed_time > 0:
                                            # 計算可能な場合は残り予想時間を表示
                                            estimated_total_time = elapsed_time * (total / current)
                                            remaining_time = max(0, estimated_total_time - elapsed_time)
                                            remaining_str = f"{int(remaining_time//60):02d}:{int(remaining_time%60):02d}"
                                            progress_info = f"ページ {current}/{total} | 経過: {elapsed_str} | 残り予想: {remaining_str}"
                                        else:
                                            # 計算できない場合は残り予想時間を非表示
                                            progress_info = f"ページ {current}/{total} | 経過: {elapsed_str}"
                                    else:
                                        # start_timeがない場合は残り予想時間を非表示
                                        progress_info = f"ページ {current}/{total}"
                                else:
                                    progress_info = f"ページ {current}/{total}"
                            
                            # ⭐修正: ダウンロード範囲情報を取得（first_url_onlyチェックを含む）⭐
                            if download_range_info and download_range_info.get('enabled'):
                                # ⭐修正: first_url_onlyモードの場合は、現在のURLが最初のURLかどうかを確認⭐
                                progress_url = latest_progress.get('url', '') or url
                                if progress_url:
                                    # _get_download_range_text()でfirst_url_onlyチェックを行う
                                    download_range_text = self._get_download_range_text(progress_url)
                                    # _get_download_range_text()が空文字列を返した場合は、download_range_infoがあっても表示しない
                                    if not download_range_text:
                                        # first_url_onlyモードで最初のURLでない場合は表示しない
                                        download_range_text = ""
                                    elif download_range_text == "":
                                        # _get_download_range_text()が空を返した場合も表示しない
                                        download_range_text = ""
                                else:
                                    download_range_text = ""
                            else:
                                # ⭐修正: _get_download_range_text()で正しく判定（URLが最初のURLかどうかを確認）⭐
                                download_range_text = self._get_download_range_text(latest_progress.get('url', '') or url)
                            
                            # 状態情報とダウンロード範囲情報を追加
                            if download_range_text:
                                latest_progress['state']['status'] = f"{progress_info} | {download_range_text} | {status}"
                            else:
                                latest_progress['state']['status'] = f"{progress_info} | {status}"
                            
                            # ⭐追加: ダウンロード範囲情報を更新（最新の情報を保存、無効になった場合は削除）⭐
                            if download_range_info:
                                if download_range_info.get('enabled'):
                                    latest_progress['download_range_info'] = download_range_info.copy()
                                else:
                                    # ⭐追加: ダウンロード範囲が無効になった場合は削除⭐
                                    if 'download_range_info' in latest_progress:
                                        del latest_progress['download_range_info']
                        else:
                            # 既存の進捗情報を含む場合はそのまま使用
                            latest_progress['state']['status'] = status
                    elif status == "":
                        # ⭐追加: statusが空文字列の場合は、既存の状態情報を保持しつつ進捗情報のみを更新⭐
                        # 既存の状態情報から「状態:」と「ダウンロード範囲」を抽出
                        existing_state = ""
                        existing_range = ""
                        if existing_status:
                            parts = existing_status.split('|')
                            for part in parts:
                                part = part.strip()
                                if part.startswith('状態:'):
                                    existing_state = part
                                elif part.startswith('ダウンロード範囲:'):
                                    existing_range = part
                        
                        # 進捗情報を生成
                        # ⭐修正: 完了状態をチェック⭐
                        is_completed = (current >= total and total > 0)
                        
                        if current > 0 and total > 0:
                            # ⭐修正: 各プログレスバーごとの開始時間を使用⭐
                            start_time = latest_progress.get('start_time')
                            if start_time:
                                elapsed_time = time.time() - start_time
                            elif hasattr(self, 'current_download_start_time') and self.current_download_start_time:
                                # フォールバック: インスタンス変数を使用
                                elapsed_time = time.time() - self.current_download_start_time
                            
                            if start_time or (hasattr(self, 'current_download_start_time') and self.current_download_start_time):
                                elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                                
                                # ⭐修正: 完了後は残り予想時間を非表示、計算できない場合も非表示⭐
                                if is_completed:
                                    # 完了後は残り予想時間を非表示
                                    progress_info = f"ページ {current}/{total} | 経過: {elapsed_str}"
                                elif current > 0 and elapsed_time > 0:
                                    # 計算可能な場合は残り予想時間を表示
                                    estimated_total_time = elapsed_time * (total / current)
                                    remaining_time = max(0, estimated_total_time - elapsed_time)
                                    remaining_str = f"{int(remaining_time//60):02d}:{int(remaining_time%60):02d}"
                                    progress_info = f"ページ {current}/{total} | 経過: {elapsed_str} | 残り予想: {remaining_str}"
                                else:
                                    # 計算できない場合は残り予想時間を非表示
                                    progress_info = f"ページ {current}/{total} | 経過: {elapsed_str}"
                            else:
                                # start_timeがない場合は残り予想時間を非表示
                                progress_info = f"ページ {current}/{total}"
                        else:
                            progress_info = f"ページ {current}/{total}"
                        
                        # ⭐修正: ダウンロード範囲情報を取得（first_url_onlyチェックを含む）⭐
                        if not existing_range:
                            # ⭐修正: download_range_infoが渡されている場合でも、first_url_onlyチェックを行う⭐
                            progress_url = latest_progress.get('url', '') or url
                            if download_range_info and download_range_info.get('enabled') and progress_url:
                                # _get_download_range_text()でfirst_url_onlyチェックを行う
                                download_range_text = self._get_download_range_text(progress_url)
                                # _get_download_range_text()が空文字列を返した場合は、download_range_infoがあっても表示しない
                                if not download_range_text:
                                    # first_url_onlyモードで最初のURLでない場合は表示しない
                                    download_range_text = ""
                            else:
                                # ⭐修正: _get_download_range_text()で正しく判定（URLが最初のURLかどうかを確認）⭐
                                download_range_text = self._get_download_range_text(progress_url)
                        else:
                            download_range_text = existing_range
                        
                        # ⭐修正: ダウンロード範囲情報を更新（最新の情報を保存、無効になった場合は削除）⭐
                        if download_range_info:
                            if download_range_info.get('enabled'):
                                latest_progress['download_range_info'] = download_range_info.copy()
                            else:
                                # ⭐追加: ダウンロード範囲が無効になった場合は削除⭐
                                if 'download_range_info' in latest_progress:
                                    del latest_progress['download_range_info']
                        
                        # ⭐修正: 状態情報を適切に分類（ダウンロード中・中断・完了・エラー）⭐
                        if not existing_state:
                            # URLの状態を取得
                            progress_url = latest_progress.get('url', '') or url
                            download_status = self._get_download_status(progress_url)
                            
                            # 状態に応じて分類
                            if download_status == "中断":
                                existing_state = "状態: 中断"
                            elif download_status == "エラー":
                                existing_state = "状態: エラー"
                            elif download_status == "完了":
                                existing_state = "状態: 完了"
                            elif current == 0 and total == 0:
                                existing_state = "状態: 待機中"
                            elif current < total:
                                existing_state = "状態: ダウンロード中"
                            elif current >= total:
                                existing_state = "状態: 完了"
                            else:
                                existing_state = "状態: ダウンロード中"
                        
                        # 状態情報とダウンロード範囲情報を追加
                        if download_range_text:
                            latest_progress['state']['status'] = f"{progress_info} | {download_range_text} | {existing_state}"
                        else:
                            latest_progress['state']['status'] = f"{progress_info} | {existing_state}"
                    else:
                        # 状態が指定されていない場合は、現在の状況に応じて適切な状態を設定
                        # ただし、既に完了状態が設定されている場合は上書きしない
                        if '完了' in existing_status or 'completed' in existing_status.lower():
                            # 完了状態は保持
                            pass
                        else:
                            # 進捗情報を生成
                            # ⭐修正: 完了状態をチェック⭐
                            is_completed = (current >= total and total > 0)
                            
                            if current > 0 and total > 0:
                                # ⭐修正: 各プログレスバーごとの開始時間を使用⭐
                                # ⭐修正: latest_progressから取得（progress_infoは文字列）⭐
                                start_time = latest_progress.get('start_time')
                                if start_time:
                                    elapsed_time = time.time() - start_time
                                elif hasattr(self, 'current_download_start_time') and self.current_download_start_time:
                                    # フォールバック: インスタンス変数を使用
                                    elapsed_time = time.time() - self.current_download_start_time
                                
                                if start_time or (hasattr(self, 'current_download_start_time') and self.current_download_start_time):
                                    elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                                    
                                    # ⭐修正: 完了後は残り予想時間を非表示、計算できない場合も非表示⭐
                                    if is_completed:
                                        # 完了後は残り予想時間を非表示
                                        progress_info = f"ページ {current}/{total} | 経過: {elapsed_str}"
                                    elif current > 0 and elapsed_time > 0:
                                        # 計算可能な場合は残り予想時間を表示
                                        estimated_total_time = elapsed_time * (total / current)
                                        remaining_time = max(0, estimated_total_time - elapsed_time)
                                        remaining_str = f"{int(remaining_time//60):02d}:{int(remaining_time%60):02d}"
                                        progress_info = f"ページ {current}/{total} | 経過: {elapsed_str} | 残り予想: {remaining_str}"
                                    else:
                                        # 計算できない場合は残り予想時間を非表示
                                        progress_info = f"ページ {current}/{total} | 経過: {elapsed_str}"
                                else:
                                    # start_timeがない場合は残り予想時間を非表示
                                    progress_info = f"ページ {current}/{total}"
                            else:
                                progress_info = f"ページ {current}/{total}"
                            
                            # ⭐修正: ダウンロード範囲情報を取得（first_url_onlyチェックを含む）⭐
                            progress_url = latest_progress.get('url', '') or url
                            saved_range_info = latest_progress.get('download_range_info')
                            if saved_range_info and saved_range_info.get('enabled'):
                                # _get_download_range_text()でfirst_url_onlyチェックを行う
                                download_range_text = self._get_download_range_text(progress_url)
                                # _get_download_range_text()が空文字列を返した場合は表示しない
                                if not download_range_text:
                                    download_range_text = ""
                            else:
                                # 保存されていない場合は従来の方法で取得
                                download_range_text = self._get_download_range_text(progress_url)
                            
                            # ⭐修正: 状態を適切に分類（ダウンロード中・中断・完了・エラー）⭐
                            # URLの状態を取得
                            progress_url = latest_progress.get('url', '') or url
                            download_status = self._get_download_status(progress_url)
                            
                            # 状態に応じて分類
                            if download_status == "中断":
                                state_text = "状態: 中断"
                            elif download_status == "エラー":
                                state_text = "状態: エラー"
                            elif download_status == "完了":
                                state_text = "状態: 完了"
                            elif download_status == "スキップ済み":
                                state_text = "状態: スキップ"
                            elif current == 0 and total == 0:
                                state_text = "状態: 待機中"
                            elif current < total:
                                state_text = "状態: ダウンロード中"
                            elif current >= total:
                                state_text = "状態: 完了"
                            else:
                                state_text = "状態: ダウンロード中"
                
                            # 状態情報とダウンロード範囲情報を追加
                            if download_range_text:
                                latest_progress['state']['status'] = f"{progress_info} | {download_range_text} | {state_text}"
                            else:
                                latest_progress['state']['status'] = f"{progress_info} | {state_text}"
                
                # ⭐削除: save_folderを保存しない（managed_foldersから動的に取得）⭐
                
                # ⭐修正: URLの情報を更新（ハイパーリンク用）⭐
                # ⭐重要: URLは既に正しく設定されているため、current_gallery_urlで上書きしない⭐
                # URLが一致する場合のみタイトルリンクを更新
                progress_url = latest_progress.get('url', '')
                if url and progress_url:
                    # URLを正規化して比較
                    if hasattr(self.parent, 'normalize_url'):
                        normalized_progress_url = self.parent.normalize_url(progress_url)
                        normalized_param_url = self.parent.normalize_url(url)
                    else:
                        normalized_progress_url = progress_url
                        normalized_param_url = url
                    
                    # URLが一致する場合のみタイトルリンクを更新
                    if normalized_progress_url == normalized_param_url:
                        self._update_title_link(latest_progress, progress_url)
                
                # ダウンロード範囲情報を更新
                
                # ⭐修正: 最新の値をクロージャーでキャプチャ（ロック内で取得、常に定義）⭐
                latest_progress_for_gui = latest_progress
                current_for_gui = current
                total_for_gui = total
                display_total_for_gui = display_total
                url_for_gui = url
                
                # totalの値が変更された場合は警告ログを出力（プログレスバー表示には影響しない）
                if old_total != total and old_total > 0:
                    # 実際の操作ページ数が変更されました
                    pass
                
                # ⭐修正: GUI更新はロック外で実行（非同期）⭐
                def update_gui():
                    try:
                        # 別ウィンドウ表示オプションがONの場合は別ウィンドウのプログレスバーを更新
                        if hasattr(self.parent, 'progress_separate_window_enabled') and self.parent.progress_separate_window_enabled.get():
                            # latest_progress_for_guiからurl_indexを取得
                            progress_url_index = latest_progress_for_gui.get('url_index')
                            if progress_url_index is not None:
                                # ステータステキストを生成
                                status_text = latest_progress_for_gui['state'].get('status', '')
                                if not status_text:
                                    # URLの状態を取得
                                    progress_url = latest_progress_for_gui.get('url', '') or url_for_gui
                                    download_status = self._get_download_status(progress_url)
                                    
                                    if current_for_gui == 0 and display_total_for_gui == 0:
                                        status_text = "状態: 待機中"
                                    elif current_for_gui < display_total_for_gui:
                                        status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 状態: {download_status}"
                                    elif current_for_gui >= display_total_for_gui:
                                        status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 状態: 完了"
                                
                                if status_text:
                                    update_url = latest_progress_for_gui.get('url', '') or url_for_gui
                                    
                                    # ステータスが変更された場合のみ即座更新
                                    status_key = f"{progress_url_index}_{status_text}"
                                    if not hasattr(self, '_last_separate_window_status'):
                                        self._last_separate_window_status = {}
                                    
                                    last_status = self._last_separate_window_status.get(status_key, '')
                                    if last_status != status_text:
                                        self._update_separate_window_progress_immediate(current_for_gui, display_total_for_gui, status_text, url=update_url, url_index=progress_url_index)
                                        self._last_separate_window_status[status_key] = status_text
                                    
                                    # 通常の非同期更新
                                    self._update_separate_window_progress(current_for_gui, display_total_for_gui, status_text, url=update_url, url_index=progress_url_index)
                        
                        # メインウィンドウのプログレスバーを更新（別ウィンドウ表示時でも更新）
                        # ⭐修正: latest_progress_for_guiを使用⭐
                        progress_bar_to_update = None
                        if latest_progress_for_gui.get('bar') and latest_progress_for_gui['bar'].winfo_exists():
                            progress_bar_to_update = latest_progress_for_gui['bar']
                        elif hasattr(self, 'current_progress_bar') and self.current_progress_bar:
                            if hasattr(self.current_progress_bar, 'winfo_exists') and self.current_progress_bar.winfo_exists():
                                progress_bar_to_update = self.current_progress_bar
                                latest_progress_for_gui['bar'] = self.current_progress_bar
                        
                        if progress_bar_to_update:
                            try:
                                if display_total_for_gui > 0:
                                    progress_value = (current_for_gui / display_total_for_gui) * 100
                                    progress_value = max(0, min(100, progress_value))
                                    progress_bar_to_update['value'] = progress_value
                                
                                # メインウィンドウのプログレスバーステータスも更新
                                if hasattr(self, 'current_progress_status') and self.current_progress_status:
                                    try:
                                        progress_url = latest_progress_for_gui.get('url', '')
                                        download_status = self._get_download_status(progress_url)
                                        
                                        # ⭐修正: 保存されたdownload_range_infoがあっても、first_url_onlyチェックを行う⭐
                                        saved_range_info = latest_progress_for_gui.get('download_range_info')
                                        if saved_range_info and saved_range_info.get('enabled'):
                                            # _get_download_range_text()でfirst_url_onlyチェックを行う
                                            download_range_text = self._get_download_range_text(progress_url)
                                            # _get_download_range_text()が空文字列を返した場合は表示しない
                                            if not download_range_text:
                                                download_range_text = ""
                                        else:
                                            download_range_text = self._get_download_range_text(progress_url)
                                        
                                        # ⭐修正: 時間情報を計算（中断時間を除外）⭐
                                        # ⭐修正: 各プログレスバーごとの開始時間を使用⭐
                                        # ⭐修正: latest_progress_for_guiを使用（クロージャでキャプチャされた値）⭐
                                        start_time = latest_progress_for_gui.get('start_time')
                                        is_completed = (download_status == "完了" or download_status == "completed" or 
                                                      current_for_gui >= display_total_for_gui)
                                        
                                        if start_time:
                                            # 中断時間を除外した経過時間を計算
                                            current_time = time.time()
                                            elapsed_time = current_time - start_time
                                            
                                            # 中断時間を除外
                                            if hasattr(self, 'total_paused_time'):
                                                elapsed_time -= self.total_paused_time
                                            
                                            # 現在中断中の場合、中断開始からの時間も除外
                                            if hasattr(self, 'download_pause_start_time') and self.download_pause_start_time:
                                                elapsed_time -= (current_time - self.download_pause_start_time)
                        
                                            # ⭐修正: 残り予想時間の表示ロジック⭐
                                            # 完了後は残り予想時間を非表示、計算できない場合も非表示
                                            if is_completed:
                                                # 完了後は残り予想時間を非表示
                                                elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                                                if download_range_text:
                                                    status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 経過: {elapsed_str} | {download_range_text} | 状態: {download_status}"
                                                else:
                                                    status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 経過: {elapsed_str} | 状態: {download_status}"
                                            elif current_for_gui > 0 and display_total_for_gui > 0 and elapsed_time > 0:
                                                # 計算可能な場合は残り予想時間を表示
                                                estimated_total_time = elapsed_time * (display_total_for_gui / current_for_gui)
                                                remaining_time = max(0, estimated_total_time - elapsed_time)
                                                
                                                elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                                                remaining_str = f"{int(remaining_time//60):02d}:{int(remaining_time%60):02d}"
                                
                                                if download_range_text:
                                                    status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 経過: {elapsed_str} | 残り: {remaining_str} | {download_range_text} | 状態: {download_status}"
                                                else:
                                                    status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 経過: {elapsed_str} | 残り: {remaining_str} | 状態: {download_status}"
                                            else:
                                                # 計算できない場合は残り予想時間を非表示
                                                elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}" if elapsed_time > 0 else "00:00"
                                                if download_range_text:
                                                    status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 経過: {elapsed_str} | {download_range_text} | 状態: {download_status}"
                                                else:
                                                    status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 経過: {elapsed_str} | 状態: {download_status}"
                                        elif hasattr(self, 'current_download_start_time') and self.current_download_start_time:
                                            # フォールバック: インスタンス変数を使用
                                            current_time = time.time()
                                            elapsed_time = current_time - self.current_download_start_time
                                            
                                            # 中断時間を除外
                                            if hasattr(self, 'total_paused_time'):
                                                elapsed_time -= self.total_paused_time
                                            
                                            # 現在中断中の場合、中断開始からの時間も除外
                                            if hasattr(self, 'download_pause_start_time') and self.download_pause_start_time:
                                                elapsed_time -= (current_time - self.download_pause_start_time)
                                            
                                            # 残り予想時間の表示ロジック
                                            if is_completed:
                                                # 完了後は残り予想時間を非表示
                                                elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                                                if download_range_text:
                                                    status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 経過: {elapsed_str} | {download_range_text} | 状態: {download_status}"
                                                else:
                                                    status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 経過: {elapsed_str} | 状態: {download_status}"
                                            elif current_for_gui > 0 and display_total_for_gui > 0 and elapsed_time > 0:
                                                # 計算可能な場合は残り予想時間を表示
                                                estimated_total_time = elapsed_time * (display_total_for_gui / current_for_gui)
                                                remaining_time = max(0, estimated_total_time - elapsed_time)
                                                
                                                elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}"
                                                remaining_str = f"{int(remaining_time//60):02d}:{int(remaining_time%60):02d}"
                                                
                                                if download_range_text:
                                                    status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 経過: {elapsed_str} | 残り: {remaining_str} | {download_range_text} | 状態: {download_status}"
                                                else:
                                                    status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 経過: {elapsed_str} | 残り: {remaining_str} | 状態: {download_status}"
                                            else:
                                                # 計算できない場合は残り予想時間を非表示
                                                elapsed_str = f"{int(elapsed_time//60):02d}:{int(elapsed_time%60):02d}" if elapsed_time > 0 else "00:00"
                                                if download_range_text:
                                                    status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 経過: {elapsed_str} | {download_range_text} | 状態: {download_status}"
                                                else:
                                                    status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 経過: {elapsed_str} | 状態: {download_status}"
                                        else:
                                            # start_timeがない場合は残り予想時間を非表示
                                            if download_range_text:
                                                status_text = f"ページ {current_for_gui}/{display_total_for_gui} | {download_range_text} | 状態: {download_status}"
                                            else:
                                                status_text = f"ページ {current_for_gui}/{display_total_for_gui} | 状態: {download_status}"
                                        
                                        self.current_progress_status.config(text=status_text)
                                        
                                        # ⭐追加: タイトルも更新（最新のタイトルを表示）⭐
                                        if hasattr(self, 'current_progress_title') and self.current_progress_title:
                                            try:
                                                saved_title = latest_progress_for_gui['state'].get('title', '')
                                                if saved_title and saved_title != "準備中...":
                                                    if hasattr(self.current_progress_title, 'winfo_exists') and self.current_progress_title.winfo_exists():
                                                        self.current_progress_title.config(text=saved_title)
                                                        # latest_progress_for_gui['title']も同期
                                                        latest_progress_for_gui['title'] = self.current_progress_title
                                            except (tk.TclError, AttributeError):
                                                pass
                                    except (tk.TclError, AttributeError):
                                        pass
                            except (tk.TclError, AttributeError):
                                pass
                    except Exception as e:
                        self.log(f"GUI更新エラー: {e}", "error")
                
                # ⭐修正: GUI更新を確実に実行⭐
                # コールバック方式の評価：
                # - 現在の設計: update_progress_async()内でupdate_gui()を定義し、root.after(0, ...)で非同期実行
                # - 問題点: update_gui()がupdate_progress_async()の実行完了まで待たされる
                # - 解決策: update_gui()を直接root.after(0, ...)で実行し、確実にGUI更新を反映
                # 
                # コールバック方式は適しているが、実行タイミングを改善する必要がある：
                # 1. update_gui()を直接root.after(0, ...)で実行（update_progress_async()の完了を待たない）
                # 2. GUI要素の存在確認を強化
                # 3. 更新を確実に実行するため、update_idletasks()を呼び出す
                if hasattr(self.parent, 'root'):
                    # ⭐修正: update_gui()を直接root.after(0, ...)で実行（確実にGUI更新を反映）⭐
                    self.parent.root.after(0, update_gui)
                    # GUI更新を確実に反映（即座に実行）
                    try:
                        self.parent.root.update_idletasks()
                    except:
                        pass
                
                # ⭐追加: メインウィンドウのプログレスバーも更新（ダウンロードマネージャーを開かなくても表示）⭐
                if not (hasattr(self.parent, 'progress_separate_window_enabled') and self.parent.progress_separate_window_enabled.get()):
                    self.parent.root.after(0, self._show_latest_progress_in_main_window)

            except Exception as e:
                self.log(f"プログレス更新エラー: {e}", "error")
        
        # ⭐修正: メインスレッドで実行されている場合は即座に実行、そうでない場合は非同期で実行⭐
        try:
            # メインスレッドで実行されているかチェック
            import threading
            if threading.current_thread() == threading.main_thread():
                # メインスレッドで実行されている場合は即座に実行
                update_progress_async()
            else:
                # バックグラウンドスレッドで実行されている場合は非同期で実行
                if hasattr(self.parent, 'root'):
                    self.parent.root.after(0, update_progress_async)
        except Exception as e:
            self.log(f"プログレス更新スケジュールエラー: {e}", "error")
            # エラー時は非同期で実行
            if hasattr(self.parent, 'root'):
                self.parent.root.after(0, update_progress_async)

    def update_progress_title(self, url, title, url_index=None):
        """プログレスタイトルを更新（スレッドセーフ）"""
        if not title:  # タイトルが無効な場合は更新しない
            return
            
        self.current_gallery_title = title  # タイトルを保存
        
        def update_title():
            try:
                with self.progress_update_lock:
                    if not self.progress_bars:
                        return
                    
                    # ⭐修正: url_indexのみで検索（URL検索は削除）⭐
                    target_progress = None
                    
                    # ⭐修正: url_indexを取得（クロージャー内で確実に定義）⭐
                    current_url_index = url_index
                    if current_url_index is None:
                        if hasattr(self.parent, 'current_url_index'):
                            current_url_index = self.parent.current_url_index
                        elif hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                            current_url_index = self.parent.downloader_core.state_manager.get_current_url_index()
                    
                    if current_url_index is not None and current_url_index >= 0:
                        # ⭐修正: StateManagerから取得を試みる⭐
                        if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                            target_progress = self.parent.downloader_core.state_manager.get_progress_bar(current_url_index)
                        else:
                            # StateManagerから取得
                            target_progress = self._get_progress_bar(current_url_index)
                    
                    # ⭐修正: url_indexが見つからない場合は更新しない⭐
                    if not target_progress:
                        self.log(f"[WARNING] update_progress_title: url_index={current_url_index}のプログレスバーが見つかりません", "warning")
                        return
                    
                    # ⭐修正: StateManagerにタイトルを保存⭐
                    target_progress['state']['title'] = title
                    if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                        self.parent.downloader_core.state_manager.update_progress_bar_state(
                            current_url_index, 
                            title=title
                        )
                    
                    # 別ウィンドウ表示オプションがONの場合は別ウィンドウのタイトルのみ更新
                    if hasattr(self.parent, 'progress_separate_window_enabled') and self.parent.progress_separate_window_enabled.get():
                        # ⭐修正: url_indexを渡す⭐
                        self._update_separate_window_title(title, url=url, url_index=current_url_index)
                        return  # 別ウィンドウ表示時はメインウィンドウのタイトル更新処理をスキップ
                    
                    # メインウィンドウのプログレスバータイトルを更新
                    # ⭐修正: target_progress['title']とself.current_progress_titleの両方を更新⭐
                    if target_progress.get('title') and target_progress['title'].winfo_exists():
                        try:
                            target_progress['title'].config(text=title)
                        except (tk.TclError, AttributeError):
                            pass
                    
                    # ⭐追加: self.current_progress_titleも更新（メインウィンドウ表示時）⭐
                    if hasattr(self, 'current_progress_title') and self.current_progress_title:
                        try:
                            if hasattr(self.current_progress_title, 'winfo_exists') and self.current_progress_title.winfo_exists():
                                self.current_progress_title.config(text=title)
                                # ⭐重要: target_progress['title']も同期⭐
                                target_progress['title'] = self.current_progress_title
                        except (tk.TclError, AttributeError):
                            pass
                    
                    # メインウィンドウのプログレスバーフレームタイトルは更新しない（固定）
                    
            except Exception as e:
                self.log(f"プログレスタイトル更新エラー: {e}", "error")
        
        # ⭐修正: GUI更新を即座に実行（メインスレッドで実行されている場合）⭐
        try:
            # メインスレッドで実行されているかチェック
            import threading
            if threading.current_thread() == threading.main_thread():
                # メインスレッドで実行されている場合は即座に実行
                update_title()
                # GUI更新を確実に反映
                if hasattr(self.parent, 'root'):
                    self.parent.root.update_idletasks()
            else:
                # バックグラウンドスレッドで実行されている場合は非同期で実行
                if hasattr(self.parent, 'root'):
                    self.parent.root.after(0, update_title)
        except Exception as e:
            self.log(f"タイトル更新スケジュールエラー: {e}", "error")
            # エラー時は非同期で実行
            if hasattr(self.parent, 'root'):
                self.parent.root.after(0, update_title)
    
    def _check_progress_retention_limit(self):
        """プログレスバーの保持数制限をチェック"""
        try:
            # ⭐修正: プログレスバー表示制限オプションをチェック⭐
            if not hasattr(self.parent, 'progress_display_limit_enabled'):
                return
            
            limit_enabled = self.parent.progress_display_limit_enabled.get() if hasattr(self.parent.progress_display_limit_enabled, 'get') else False
            if not limit_enabled:
                return
            
            # 保持数を取得
            retention_count = 100  # デフォルト
            if hasattr(self.parent, 'progress_retention_count'):
                try:
                    retention_count = int(self.parent.progress_retention_count.get())
                except (ValueError, TypeError):
                    retention_count = 100
            
            # ⭐修正: self.parent.state_managerを使用⭐
            all_progress = self.parent.state_manager.get_all_progress_bars()
            if not all_progress:
                return
            
            # 完了したプログレスバーのみをフィルタ
            completed_progress = []
            for url_index, progress in all_progress.items():
                if self._is_progress_completed(progress):
                    completed_progress.append((url_index, progress))
            
            # 保持数を超えた場合、古いものから削除
            if len(completed_progress) > retention_count:
                # タイムスタンプでソート（古い順）
                completed_progress.sort(key=lambda x: x[1].get('state', {}).get('last_update', 0))
                
                # 超過分を削除
                to_remove = completed_progress[:-retention_count]
                for url_index, _ in to_remove:
                    self.parent.state_manager.remove_progress_bar(url_index)
                    self.log(f"[プログレスバー表示制限] 完了済みプログレスバー {url_index+1} を削除", "debug")
                
        except Exception as e:
            self.log(f"プログレスバー保持数制限チェックエラー: {e}", "error")
                
    def _is_progress_completed(self, progress):
        """プログレスバーが完了しているかチェック"""
        try:
            if not progress:
                return False
            
            status = progress.get('state', {}).get('status', '')
            # 完了、エラー、スキップの状態をチェック
            if any(keyword in status for keyword in ['完了', 'completed', 'error', 'エラー', 'skipped', 'スキップ']):
                return True
            
            # 進捗が100%に達しているかチェック
            current = progress.get('state', {}).get('current', 0)
            total = progress.get('state', {}).get('total', 0)
            if total > 0 and current >= total:
                return True
            
            return False
        except Exception:
            return False
    
    def _refresh_gui_state(self):
        """GUI更新ボタンが押された時の処理"""
        try:
            # フォルダボタンの状態を更新
            self._update_folder_buttons_state()
            
            # プログレスバーの表示を更新
            if hasattr(self, 'separate_window_progress_bars'):
                for progress in self.separate_window_progress_bars:
                    try:
                        # プログレスバーの状態を再描画
                        if 'bar' in progress and progress['bar']:
                            progress['bar'].update_idletasks()
                        if 'status' in progress and progress['status']:
                            progress['status'].update_idletasks()
                    except Exception:
                        pass
            
            self.log("GUI状態を更新しました", "info")
        except Exception as e:
            self.log(f"GUI状態更新エラー: {e}", "error")
    
    def _restore_progress_bars(self, progress_bars: dict) -> int:
        """
        プログレスバー状態を復元（10000件対応の効率的実装）
        
        Args:
            progress_bars: 復元するプログレスバー情報（url_index -> progress_info）
        
        Returns:
            復元した件数
        """
        try:
            restored_count = 0
            
            for url_index, progress_info in progress_bars.items():
                try:
                    url = progress_info.get('url', '')
                    current = progress_info.get('current', 0)
                    total = progress_info.get('total', 0)
                    title = progress_info.get('title', '')
                    status = progress_info.get('status', '')
                    save_folder = progress_info.get('save_folder', '')
                    download_range_info = progress_info.get('download_range_info', None)
                    elapsed_seconds = progress_info.get('elapsed_time_seconds', 0.0)
                    
                    # プログレスバーを作成（update_progress_displayを使用）
                    # まずタイトルを設定
                    if title:
                        self.update_progress_title(url, title, url_index=int(url_index))
                    
                    # プログレスバーを表示
                    self.update_progress_display(
                        url=url,
                        current=current,
                        total=total,
                        title_override=title,
                        status_text_override=status,
                        download_range_info=download_range_info
                    )
                    
                    # 経過時間を復元（個別プログレスバーに記録）
                    if elapsed_seconds > 0:
                        # プログレスバー情報を取得
                        progress = self._get_progress_bar(int(url_index))
                        if progress:
                            # 開始時刻を計算（現在時刻 - 経過時間）
                            import time
                            start_time = time.time() - elapsed_seconds
                            progress['start_time'] = start_time
                            progress['elapsed_time'] = elapsed_seconds
                            # StateManagerにも保存
                            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                                self.parent.downloader_core.state_manager.update_progress_bar_state(
                                    int(url_index),
                                    elapsed_time=elapsed_seconds
                                )
                    
                    # スレッド詳細情報を復元
                    thread_details = progress_info.get('thread_details', {})
                    if thread_details:
                        self._restore_thread_details(int(url_index), thread_details)
                    
                    restored_count += 1
                    
                except Exception as e:
                    self.log(f"プログレスバー復元エラー（URL index: {url_index}）: {e}", "warning")
                    import traceback
                    self.log(f"詳細: {traceback.format_exc()}", "debug")
                    continue
            
            return restored_count
            
        except Exception as e:
            self.log(f"プログレスバー一括復元エラー: {e}", "error")
            import traceback
            self.log(f"エラー詳細: {traceback.format_exc()}", "error")
            return 0
    
    def _restore_elapsed_time(self, url_index: int, elapsed_seconds: float):
        """経過時間を復元"""
        try:
            progress = self._get_progress_bar(url_index)
            if progress:
                progress['elapsed_time_seconds'] = elapsed_seconds
                
                # 経過時間の表示を更新
                if 'elapsed' in progress and progress['elapsed']:
                    hours = int(elapsed_seconds // 3600)
                    minutes = int((elapsed_seconds % 3600) // 60)
                    seconds = int(elapsed_seconds % 60)
                    progress['elapsed'].config(text=f"{hours:02d}:{minutes:02d}:{seconds:02d}")
        except Exception as e:
            self.log(f"経過時間復元エラー（URL index: {url_index}）: {e}", "debug")
    
    def _restore_thread_details(self, url_index: int, thread_details: dict):
        """スレッド詳細情報を復元"""
        try:
            progress = self._get_progress_bar(url_index)
            if progress:
                progress['thread_details'] = thread_details
                # スレッド詳細情報はGUIには表示されないが、内部状態として保持
        except Exception as e:
            self.log(f"スレッド詳細復元エラー（URL index: {url_index}）: {e}", "debug")
    
    def _setup_progress_tracker_observer(self):
        """⭐Phase1: ProgressTrackerのオブザーバーを設定⭐"""
        try:
            if not hasattr(self.parent, 'downloader_core'):
                return
            
            downloader_core = self.parent.downloader_core
            if not hasattr(downloader_core, 'progress_tracker'):
                return
            
            # ThrottledProgressObserver経由で登録（500msに1回だけ更新）
            from core.progress_tracker import ThrottledProgressObserver
            
            def on_progress_update(snapshot):
                """進捗更新のコールバック"""
                try:
                    # GUIスレッドで実行
                    self.parent.root.after(0, lambda: self._handle_progress_snapshot(snapshot))
                except Exception as e:
                    self.log(f"[ProgressTracker] 進捗更新エラー: {e}", "error")
            
            throttled_observer = ThrottledProgressObserver(
                callback=on_progress_update,
                min_interval_ms=500  # 500msに1回だけGUI更新
            )
            
            downloader_core.progress_tracker.subscribe(throttled_observer)
            self.log("[ProgressTracker] オブザーバー登録完了（500ms間隔で間引き）", "debug")
            
        except Exception as e:
            self.log(f"[ProgressTracker] オブザーバー設定エラー: {e}", "error")
    
    def _setup_state_manager_observer(self):
        """⭐追加: StateManagerのオブザーバーを設定（プログレスバー更新用）⭐"""
        try:
            if not hasattr(self.parent, 'downloader_core'):
                return
            
            downloader_core = self.parent.downloader_core
            if not hasattr(downloader_core, 'state_manager'):
                return
            
            # StateManagerにオブザーバーとして登録
            downloader_core.state_manager.attach_observer(self)
            self.log("[StateManager] プログレスバー更新用オブザーバー登録完了", "debug")
            
        except Exception as e:
            self.log(f"[StateManager] オブザーバー設定エラー: {e}", "error")
    
    def on_progress_updated(self, url_index: int, data: dict):
        """⭐追加: StateManagerからの進捗更新通知（Observerインターフェース）⭐"""
        try:
            # ⭐DEBUG: Observer受信のログ⭐
            self.log(f"[DEBUG] Observer受信: url_index={url_index}, current={data.get('current')}/{data.get('total')}, status={data.get('status')}", "debug")
            
            # GUIスレッドで実行
            def update_gui():
                try:
                    self._handle_state_manager_progress(url_index, data)
                except Exception as e:
                    self.log(f"[StateManager] GUI更新処理エラー: {e}", "error")
                    import traceback
                    traceback.print_exc()
            
            self.parent.root.after(0, update_gui)
        except Exception as e:
            self.log(f"[StateManager] 進捗更新スケジュールエラー: {e}", "error")
    
    def _handle_state_manager_progress(self, url_index: int, data: dict):
        """⭐修正: StateManagerからの進捗通知でGUI更新（シンプル版）⭐"""
        try:
            if url_index is None or url_index < 0:
                self.log(f"[DEBUG] _handle_state_manager_progress: 無効なurl_index={url_index}", "debug")
                return
            
            # ⭐DEBUG: GUI更新の呼び出し確認⭐
            self.log(f"[DEBUG] GUI更新開始: url_index={url_index}, current={data.get('current')}/{data.get('total')}", "debug")
            
            # ⭐修正: StateManagerから最新情報を取得⭐
            fresh_info = None
            if hasattr(self.parent, 'downloader_core') and hasattr(self.parent.downloader_core, 'state_manager'):
                fresh_info = self.parent.downloader_core.state_manager.get_progress_bar(url_index)
                if fresh_info:
                    title = fresh_info.get('title', '') or fresh_info.get('state', {}).get('title', '')
                    status = fresh_info.get('status', '') or fresh_info.get('state', {}).get('status', '')
                    self.log(f"[DEBUG] StateManagerから取得: title='{title[:30]}...', status={status}, fresh_info_keys={list(fresh_info.keys())}", "debug")
                else:
                    self.log(f"[DEBUG] StateManagerからの取得失敗: url_index={url_index}", "debug")
            
            # ⭐重要: 取得した情報を直接渡す（二重取得を防ぐ）⭐
            self.log(f"[DEBUG] _ensure_progress_bar_gui()呼び出し前: url_index={url_index}, fresh_info={'あり' if fresh_info else 'なし'}", "debug")
            self._ensure_progress_bar_gui(url_index, progress_info=fresh_info, is_main_window=True)
            self.log(f"[DEBUG] _ensure_progress_bar_gui()呼び出し後: url_index={url_index}", "debug")
            
            # 別ウィンドウがあれば更新（ダウンロードマネージャーは明示的にdataを使用）
            if self.separate_window:
                # ダウンロードマネージャーは通知されたdataを使用（リアルタイム性重視）
                progress_info = {
                    'current': data.get('current', 0),
                    'total': data.get('total', 1),
                    'title': data.get('title', ''),
                    'status': data.get('status', ''),
                    'url': data.get('url', ''),
                    'download_range_info': data.get('download_range_info'),
                    'start_time': data.get('start_time')
                }
                self._ensure_progress_bar_gui(url_index, progress_info, is_main_window=False)
                
        except Exception as e:
            self.log(f"[StateManager] GUI更新エラー: {e}", "error")
            import traceback
            traceback.print_exc()
    
    def _handle_progress_snapshot(self, snapshot):
        """⭐Phase1: ProgressSnapshotを受け取ってGUI更新⭐"""
        try:
            from core.progress_tracker import DownloadPhase
            
            # デバッグログ（将来的なProgressTracker完全移行用）
            # 現在はStateManager経由で更新されるため、ここでの処理は不要
            # self.log(f"[ProgressTracker] 進捗受信: Phase={snapshot.phase.value}, "
            #         f"{snapshot.current}/{snapshot.total} ({snapshot.progress_percent:.1f}%), "
            #         f"Status={snapshot.status}", "debug")
            
            # 既存のStateManager経由での更新もサポート（移行期間の互換性）
            # TODO: 完全移行後はこの処理を削除し、ProgressTrackerのみに統一
            
        except Exception as e:
            self.log(f"[ProgressTracker] スナップショット処理エラー: {e}", "error")
